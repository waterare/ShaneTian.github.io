<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>在服务器部署Jupyter Notebook</title>
      <link href="/2019/02/jupyter-notebook.html"/>
      <url>/2019/02/jupyter-notebook.html</url>
      
        <content type="html"><![CDATA[<p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。它的核心在于展示与快速迭代。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>一般通过两种方式来安装Jupyter Notebook，但由于Anaconda的易用性，一般推荐第一种方式。</p><ol><li>Anaconda。如果服务器已经安装了Anaconda作为Python的解释器，那么你不需要任何操作；</li><li><code>pip3 install jupyter</code>（或<code>pip install jupyter</code>），使用Python的包管理命令来安装最新版本。</li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>安装完成之后，简单几步即可完成Jupyter Notebook的部署。</p><ol><li>创建一个主目录。<code>mkdir /root/jpynotebook</code>（目录名字可以随意，与后面配置文件中保持一致）；</li><li>生成配置文件。<code>jupyter-notebook --generate-config</code>；</li><li><p>生成密码。输入<code>ipython</code>打开iPython，输入：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure><p> 之后两次输入密码则会自动生成以<code>sha1:</code>开头的密码hash值，复制出来后面填写；</p></li><li><p>修改配置文件。<code>vim /root/.jupyter/jupyter_notebook_config.py</code>，打开后在文件头插入：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip=<span class="string">'当前服务器IP'</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1:......'</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">u'/root/jpynotebook'</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="keyword">False</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8888</span></span><br><span class="line">c.NotebookApp.allow_root = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p> <code>:wq</code>保存退出；</p></li><li>使用<code>nohup</code>启动服务。<code>nohup jupyter-notebook --config=/root/.jupyter/jupyter_notebook_config.py &amp;</code>；</li><li>在浏览器输入<code>http://服务器IP:8888</code>即可访问。</li></ol><p><strong>Happy coding！</strong><br><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0l3kub58dj31su0lmn0i.jpg" alt=""></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Jupyter Notebook有两种不同的键盘输入模式。<strong>编辑模式</strong>允许您将代码或文本输入到一个单元格中，并通过一个绿色的单元格来表示；<strong>命令模式</strong>将键盘与笔记本级命令绑定在一起，并通过一个灰色的单元格边界显示，该边框为蓝色的左边框。<br>以<code>macOS</code>为例。</p><h3 id="命令模式（按下Esc，单元格为蓝色）"><a href="#命令模式（按下Esc，单元格为蓝色）" class="headerlink" title="命令模式（按下Esc，单元格为蓝色）"></a>命令模式（按下<kbd>Esc</kbd>，单元格为蓝色）</h3><ul><li><kbd>F</kbd>：查找与替换；</li><li><kbd>⌃↩︎</kbd>：运行所选代码块（适用于编辑模式）；</li><li><kbd>⇧↩︎</kbd>：运行所选代码块，并选中下一个代码块（适用于编辑模式）；</li><li><kbd>⌥↩︎</kbd>：运行所选代码块，并在下面插入新的代码块（适用于编辑模式）；</li><li><kbd>Y</kbd>：将当前单元格切换为代码；</li><li><kbd>M</kbd>：将当前单元格切换为标签（Markdown）；</li><li><kbd>R</kbd>：将当前单元格切换为Raw NBConvert。Raw NBConvert中的文字或代码等都不会被运行；</li><li><kbd>1~6</kbd>：将当前单元格切换为标题；</li><li><kbd>↑</kbd>：选中上面的单元格；</li><li><kbd>↓</kbd>：选中下面的单元格；</li><li><kbd>⇧↑</kbd>：扩选中上面的单元格；</li><li><kbd>⇧↓</kbd>：扩选中下面的单元格；</li><li><kbd>⇧M</kbd>：合并选中单元格；</li><li><kbd>A</kbd>：在上面插入代码块；</li><li><kbd>B</kbd>：在下面插入代码块；</li><li><kbd>X</kbd>：剪切当前单元格；</li><li><kbd>C</kbd>：复制当前单元格；</li><li><kbd>V</kbd>：粘贴到下面；</li><li><kbd>⇧V</kbd>：粘贴到上面；</li><li><kbd>DD</kbd>：删除当前单元格；</li><li><kbd>Z</kbd>：撤销删除；</li><li><kbd>S</kbd>：保存并检查；</li><li><kbd>L</kbd>：显示行号与否；</li><li><kbd>⇧L</kbd>：所有单元格显示行号与否；</li><li><kbd>O</kbd>：显示单元格的输出与否；</li><li><kbd>II</kbd>：中断Jupyter服务；</li><li><kbd>00</kbd>：重启Jupyter服务。</li></ul><h3 id="编辑模式（按下↩︎，单元格为绿色）"><a href="#编辑模式（按下↩︎，单元格为绿色）" class="headerlink" title="编辑模式（按下↩︎，单元格为绿色）"></a>编辑模式（按下<kbd>↩︎</kbd>，单元格为绿色）</h3><ul><li><kbd>⇥</kbd>：代码补全或缩进；</li><li><kbd>⇧⇥</kbd>：取消代码缩进；</li><li><kbd>⌘A</kbd>：全选；</li><li><kbd>⌘Z</kbd>：撤销；</li><li><kbd>⌘⇧Z</kbd>：重做；</li><li><kbd>⌘S</kbd>：保存并检查；</li><li><kbd>⌘/</kbd>：注释；</li><li><kbd>⌘D</kbd>：删除整行；</li><li><kbd>⌥←</kbd>：跳到单词左边；</li><li><kbd>⌥→</kbd>：跳到单词右边；</li><li><kbd>⌥⌫</kbd>：删除前面的单词；</li><li><kbd>⌥⌦</kbd>：删除后面的单词；</li><li><kbd>⌘⌫</kbd>：删除光标前面的所有；</li><li><kbd>⌘⌦</kbd>：删除光标后面的所有；</li><li><kbd>⌃⇧-</kbd>：在鼠标出分割代码块。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>广义表的一些概念</title>
      <link href="/2019/02/generalized-list.html"/>
      <url>/2019/02/generalized-list.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>广义表（Lists，又称列表）是线性表的推广。广义表是$n(n\geqslant 0)$个元素$a_1,a_2,a_3,…,a_n$的有限序列，其中$a_i$或者是原子项，或者是一个广义表。<br><a id="more"></a></p><ul><li><strong>元素</strong>：广义表的元素可以是原子，也可以是广义表，也可以为空。</li><li><strong>表头</strong>：若广义表$LS（n\geqslant 1)$非空，则$a_1$是LS的表头。表头可以是单元素值，也可以是表。空的广义表不能求表头。</li><li><strong>表尾</strong>：若广义表$LS（n\geqslant 1)$非空，则除去表头后剩下的元素组成的表是LS的表尾。表尾一定是表。空的广义表不能求表尾。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li>$A=()$——A是一个空表，其长度为零。</li><li>$B=(e)$——表B只有一个原子$e$，其长度为1。</li><li>$C=(a,(b,c,d))$——表C的长度为2，两个元素分别为原子$a$和子表$(b,c,d)$，其表尾为$((b,c,d))$。</li><li>$D=(A，B，C)$——表D的长度为3，三个元素都是广义表。显然，将子表的值代入后，则有$D=((),(e),(a,(b,c,d)))$。</li><li>$E=(a,E)$——这是一个递归的表，它的长度为2，E相当于一个无限的广义表$E=(a,(a,(a,(a,…))))$.</li></ol><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ol><li>广义表是0个或多个单因素或子表组成的有限序列，广义表可以是自身的子表，广义表的长度$n\geqslant 0$，所以可以为空表。广义表的同级元素(直属于同一个表中的各元素)具有线性关系。</li><li>广义表的表头为空，并不代表该广义表为空表。广义表$()$和$(())$不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为1的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表$()$。</li><li>已知广义表$LS＝((a,b,c),(d,e,f))$,运用$head$和$tail$函数取出LS中原子$e$的运算是$head(tail(head(tail(LS)))$。根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。也就是说，广义表的$head$操作，取出的元素是什么，那么结果就是什么。但是$tail$操作取出的元素外必须加一个表——“$()$“。$tail(LS)＝((d,e,f))$；$head(tail(LS))=(d,e,f)$；$tail(head(tail(LS)))=(e,f)$；$head(tail(head(tail(LS))))=e$。</li><li>二维以上的数组其实是一种特殊的广义表。</li><li>在（非空）广义表中：1、表头$head$可以是原子或者一个表；2、表尾$tail$一定是一个表；3.广义表难以用顺序存储结构；4.广义表可以是一个多层次的结构。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md#%E5%B9%BF%E4%B9%89%E8%A1%A8" target="_blank" rel="noopener">数据结构：广义表</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 广义表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017校招真题--小米--「电话号码分身」</title>
      <link href="/2019/02/recruit-telephone-number.html"/>
      <url>/2019/02/recruit-telephone-number.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>继MIUI8推出手机分身功能之后，MIUI9计划推出一个电话号码分身的功能：首先将电话号码中的每个数字加上8取个位，然后使用对应的大写字母代替 （”ZERO”, “ONE”, “TWO”, “THREE”, “FOUR”, “FIVE”, “SIX”, “SEVEN”, “EIGHT”, “NINE”）， 然后随机打乱这些字母，所生成的字符串即为电话号码对应的分身。<br><strong>输入描述:</strong></p><blockquote><p>第一行是一个整数T（1 ≤ T ≤ 100)表示测试样例数；接下来T行，每行给定一个分身后的电话号码的分身（长度在3到10000之间）。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>输出T行，分别对应输入中每行字符串对应的分身前的最小电话号码（允许前导0）。<br><a id="more"></a><br><strong>示例1</strong><br>输入</p><blockquote><p>4<br>EIGHT<br>ZEROTWOONE<br>OHWETENRTEO<br>OHEWTIEGTHENRTEO</p></blockquote><p>输出</p><blockquote><p>0<br>234<br>345<br>0345</p></blockquote></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>分身步骤：+8取个位—使用大写字母代替—随机打乱字母；</li><li>给的输入是分身后的电话号码，需要输出为分身前的最小电话号码。实际上问题的本质是需要从乱序的大写字母版数字组合中识别出数字及其个数；</li><li>思路：部分单词有唯一识别字母，如’ZERO’的’Z’，可以先把这部分数出来；剩下的单词又可以通过在剩下单词中的唯一识别字母识别（后减去之前识别出有重复字母的单词个数即为当前单词个数）；</li><li><strong>别忘了最后需要将数字的个数映射回去（减去8）。</strong></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(3.5.2)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = int(input())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(num):</span><br><span class="line">    s = input()</span><br><span class="line">    n0, n2, n4, n6, n8 = s.count(<span class="string">'Z'</span>), s.count(<span class="string">'W'</span>), s.count(<span class="string">'U'</span>), s.count(<span class="string">'X'</span>), s.count(<span class="string">'G'</span>)</span><br><span class="line">    n1, n3, n5, n7 = s.count(<span class="string">'O'</span>) - n0 - n2 - n4, s.count(<span class="string">'H'</span>) - n8, s.count(<span class="string">'F'</span>) - n4, s.count(<span class="string">'S'</span>) - n6</span><br><span class="line">    n9 = s.count(<span class="string">'I'</span>) - n5 - n6 - n8</span><br><span class="line">    print(<span class="string">'0'</span> * n8 + <span class="string">'1'</span> * n9 + <span class="string">'2'</span> * n0 + <span class="string">'3'</span> * n1 + <span class="string">'4'</span> * n2 + <span class="string">'5'</span> * n3 + <span class="string">'6'</span> * n4 + <span class="string">'7'</span> * n5 + <span class="string">'8'</span> * n6 + <span class="string">'9'</span> * n7)</span><br></pre></td></tr></table></figure></p><p><code>运行时间：34ms</code><br><code>占用内存：3688k</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.nowcoder.com/profile/6259171/codeBookDetail?submissionId=28510058" target="_blank" rel="noopener">https://www.nowcoder.com/profile/6259171/codeBookDetail?submissionId=28510058</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>队列的基础知识+Python实现</title>
      <link href="/2019/02/queue.html"/>
      <url>/2019/02/queue.html</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出(FIFO)。<br><a id="more"></a></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>为充分利用向量空间，克服”假上溢”现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。即：循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（QueueSize-1）时，其加1操作的结果是指向向量的下界0。</p><p><center><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0hkwsivzsj30wl0kkq4h.jpg" width="50%" alt="循环队列"></center></p><ol><li>队空条件：<code>rear=front</code>；</li><li>队满条件：<code>(rear+1)%capacity=front</code>。有两种情况：1.<code>front=rear+1</code>（如图）；2.<code>front=0</code>且<code>rear=capacity-1</code>。使用取余运算可以简单涵盖这两种情况；</li><li>队列长度：<code>(rear-front+capacity)%capacity</code>；</li><li>入队：<code>rear=(rear+1)%capacity</code>；</li><li>出队：<code>front=(front+1)%capacity</code>。</li></ol><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>使用Python中的list可以简单的实现队列。</p><h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""maxsize&lt;=0代表队列不限定大小"""</span></span><br><span class="line">        self.queue = []</span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_full</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.maxsize &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> len(self.queue) == self.maxsize</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""入队"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_full():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Queue is full!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""出队"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队头元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队尾元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_queue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue</span><br></pre></td></tr></table></figure><h3 id="循环队列-1"><a href="#循环队列-1" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""循环队列"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""capacity是队列大小，但实际大小为capacity-1，由于尾指针浪费了一个位置"""</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.queue = [<span class="keyword">None</span>] * capacity</span><br><span class="line">        self.front, self.rear = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front == self.rear</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_full</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 1.front=rear+1；2.front=0，rear=capacity-1</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear + <span class="number">1</span>) % self.capacity == self.front</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_full():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Queue is full!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.queue[self.rear] = item</span><br><span class="line">            self.rear = (self.rear + <span class="number">1</span>) % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = self.queue[self.front]</span><br><span class="line">            self.queue[self.front] = <span class="keyword">None</span></span><br><span class="line">            self.front = (self.front + <span class="number">1</span>) % self.capacity</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.rear - self.front + self.capacity) % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[self.front]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"Queue is empty!"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.queue[(self.rear - <span class="number">1</span> + self.capacity) % self.capacity]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_queue</span><span class="params">(self)</span>:</span></span><br><span class="line">        tmp = self.front</span><br><span class="line">        ls = []</span><br><span class="line">        <span class="keyword">while</span> tmp != self.rear:</span><br><span class="line">            ls.append(self.queue[tmp])</span><br><span class="line">            tmp = (tmp + <span class="number">1</span>) % self.capacity</span><br><span class="line">        <span class="keyword">return</span> ls</span><br></pre></td></tr></table></figure><h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_Q</span><span class="params">()</span>:</span></span><br><span class="line">    Q = Queue()</span><br><span class="line">    print(<span class="string">"队列是否为空："</span>, Q.is_empty())</span><br><span class="line">    print(<span class="string">"入队'1'"</span>)</span><br><span class="line">    Q.enqueue(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"队列大小："</span>, Q.size())</span><br><span class="line">    print(<span class="string">"入队'2'"</span>)</span><br><span class="line">    Q.enqueue(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"队头元素："</span>, Q.get_front())</span><br><span class="line">    print(<span class="string">"出队："</span>, Q.dequeue())</span><br><span class="line">    print(<span class="string">"队头元素："</span>, Q.get_front())</span><br><span class="line">    <span class="comment"># print("出队：", Q.dequeue())</span></span><br><span class="line">    print(<span class="string">"队尾元素："</span>, Q.get_rear())</span><br><span class="line">    print(<span class="string">"队列为："</span>, Q.print_queue())</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_CQ</span><span class="params">()</span>:</span></span><br><span class="line">    CQ = CircleQueue(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"循环队列是否为空："</span>, CQ.is_empty())</span><br><span class="line">    print(<span class="string">"入队'1'"</span>)</span><br><span class="line">    CQ.enqueue(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"入队'2'"</span>)</span><br><span class="line">    CQ.enqueue(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"队头元素："</span>, CQ.get_front())</span><br><span class="line">    print(<span class="string">"入队'3'"</span>)</span><br><span class="line">    CQ.enqueue(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"循环队列是否为满："</span>, CQ.is_full())</span><br><span class="line">    print(<span class="string">"出队："</span>, CQ.dequeue())</span><br><span class="line">    print(<span class="string">"队尾元素："</span>, CQ.get_rear())</span><br><span class="line">    print(<span class="string">"循环队列为："</span>, CQ.print_queue())</span><br></pre></td></tr></table></figure><h2 id="队列的应用—击鼓传花大逃杀"><a href="#队列的应用—击鼓传花大逃杀" class="headerlink" title="队列的应用—击鼓传花大逃杀"></a>队列的应用—击鼓传花大逃杀</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>你和你的 39 个同学外出露营，晚上无聊时，大家围在火堆边做游戏。游戏规则如下：40人围成一个圈，其中一人被指定为第一个人，顺时针报数到第七人，就将他杀死。之后，下一个活着的人继续报数，每次都是杀死第七个人。直到只剩一人时，游戏结束。如果你并不想死，那么应该坐到哪里才能成为最后一人？（假设第一个报数者的位置记为1）</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>如果能想到将这个问题抽象为一个简单队列的问题，那么就已经解决了一大半。</p><ul><li>报数而不被杀的人：相当于从队首出队再从队尾入队；</li><li>被杀的人：只出队；</li><li>留到最后的人：当队列长度为1时，再出队一次，返回。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataosha</span><span class="params">(name_list, kill_num=<span class="number">7</span>)</span>:</span></span><br><span class="line">    <span class="string">"""击鼓传花大逃杀"""</span></span><br><span class="line">    Q = Queue()</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line">        Q.enqueue(name)</span><br><span class="line">    <span class="keyword">while</span> Q.size() &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(kill_num - <span class="number">1</span>):</span><br><span class="line">            Q.enqueue(Q.dequeue())</span><br><span class="line">        print(<span class="string">"Kill:"</span>, Q.dequeue())</span><br><span class="line">    <span class="keyword">return</span> Q.dequeue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">40</span>):</span><br><span class="line">    name_list.append(i + <span class="number">1</span>)</span><br><span class="line">print(<span class="string">"Safe number:"</span>, dataosha(name_list))</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Safe number: 24</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md#%E9%98%9F%E5%88%97" target="_blank" rel="noopener">数据结构：队列</a><br><a href="https://blog.csdn.net/Annihilation7/article/details/82847774" target="_blank" rel="noopener">https://blog.csdn.net/Annihilation7/article/details/82847774</a><br><a href="https://blog.csdn.net/theLostLamb/article/details/79233615" target="_blank" rel="noopener">https://blog.csdn.net/theLostLamb/article/details/79233615</a><br><a href="https://www.jianshu.com/p/ecb1e515a3f4" target="_blank" rel="noopener">https://www.jianshu.com/p/ecb1e515a3f4</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈的基础知识+Python实现</title>
      <link href="/2019/02/stack.html"/>
      <url>/2019/02/stack.html</url>
      
        <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈(Stack，堆栈)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出(FILO)。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增。</p><ol><li>顺序存储栈：顺序存储结构；</li><li>链栈：链式存储结构。插入和删除操作仅限制在链头位置上进行。栈顶指针就是链表的头指针。通常不会出现栈满的情况。 不需要判断栈满但需要判断栈空；</li><li>堆栈溢出一般是循环的递归调用、大数据结构的局部变量导致的。<a id="more"></a></li></ol><h3 id="栈的复杂度"><a href="#栈的复杂度" class="headerlink" title="栈的复杂度"></a>栈的复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p><strong>平均：</strong></p><div class="table-container"><table><thead><tr><th></th><th>访问</th><th>搜索</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>栈</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><p><strong>最差：</strong></p><div class="table-container"><table><thead><tr><th></th><th>访问</th><th>搜索</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>栈</td><td>O(n)</td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p><strong>最差：</strong>O(n)</p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>使用Python中的list可以简单的实现堆栈。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""堆栈"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.items[len(self.items) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""压栈"""</span></span><br><span class="line">        <span class="keyword">return</span> self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""出栈"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    S = Stack()</span><br><span class="line">    print(<span class="string">'栈是否为空：'</span>, S.is_empty())</span><br><span class="line">    print(<span class="string">"压栈'2'"</span>)</span><br><span class="line">    S.push(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'栈顶为：'</span>, S.peek())</span><br><span class="line">    print(<span class="string">"压栈'3'"</span>)</span><br><span class="line">    S.push(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"栈顶为："</span>, S.peek())</span><br><span class="line">    print(<span class="string">"出栈"</span>)</span><br><span class="line">    S.pop()</span><br><span class="line">    print(<span class="string">"栈的大小："</span>, S.size())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md#%E6%A0%88" target="_blank" rel="noopener">数据结构：栈</a><br><a href="https://blog.csdn.net/xuqiang20121991/article/details/54139431" target="_blank" rel="noopener">https://blog.csdn.net/xuqiang20121991/article/details/54139431</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]正则表达式匹配</title>
      <link href="/2019/02/target-offer-regulation.html"/>
      <url>/2019/02/target-offer-regulation.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配<br><a id="more"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>总体上，分为两种情况：模式中第二个字符不是‘*’、模式中第二个字符是‘*’。第一种情况，检查字符串首位和模式首位字符是否相匹配，成功则均后移一位，失败则返回False。第二种情况，需要分为三种情况：‘*’前面的字符匹配多次（贪婪匹配）、匹配1次、匹配0次，分别对字符串和模式进行相应后移。</li><li>《剑指Offer》原文：<center><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0gk8sk4fzj30qq0cytcg.jpg" width="50%" alt="《剑指Offer》原文"></center></li><li>特殊输入测试：空字符串、空模式、含’.’模式、含’*‘模式、普通模式。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s, pattern都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pattern:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="comment"># 都空返回True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> pattern[<span class="number">0</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="comment"># 模式第二位为*的情况</span></span><br><span class="line">            <span class="keyword">if</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>)):</span><br><span class="line">                <span class="comment"># *之前的字符与s首位相符且s不为空：递归调用贪婪匹配（将字符串后移一位，模式不变）或匹配到0次（字符串不变，模式后移两位）。（不用考虑匹配1次：相当于递归中贪婪匹配的匹配0次）</span></span><br><span class="line">                <span class="comment"># 本来考虑这里只需要递归self.match(s[1:], pattern)，其实需要将这两种都加上，见后文【经典测试用例】。此处两种对应贪婪匹配、匹配0次</span></span><br><span class="line">                <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern) <span class="keyword">or</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># *之前的字符与s首位不符或者s为空，直接将模式后移两位递归，相当于匹配到0次</span></span><br><span class="line">                <span class="keyword">return</span> self.match(s, pattern[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">elif</span> (len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>)):</span><br><span class="line">            <span class="comment"># 模式第二位不是*的情况：匹配到就都后移一位递归，未匹配到就返回False</span></span><br><span class="line">            <span class="keyword">return</span> self.match(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p><code>运行时间：25ms</code><br><code>占用内存：5736k</code></p><h3 id="经典测试用例"><a href="#经典测试用例" class="headerlink" title="经典测试用例"></a>经典测试用例</h3><p>用例：<code>s = &#39;bbbba&#39;, pattern = &#39;.\*a\*a&#39;</code><br>如果前面只递归调用<code>self.match(s[1:], pattern)</code>，那么相当于贪婪匹配，只要模式是<code>.*</code>就一直缩减s进行递归，到最后s为空时返回False。加上<code>self.match(s, pattern[2:])</code>后，相当于字符串不变，模式向后缩两位，对于<code>s = &#39;a&#39;, pattern = &#39;a\*a&#39;</code>即可返回True。所以二者缺一不可。<br><strong>不需要加<code>self.match(s[1:], pattern[2:])</code>的原因</strong>是贪婪匹配的递归中的匹配0次相当于匹配1次。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.nowcoder.com/profile/7165145/codeBookDetail?submissionId=12509063" target="_blank" rel="noopener">https://www.nowcoder.com/profile/7165145/codeBookDetail?submissionId=12509063</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]反转链表</title>
      <link href="/2019/02/target-offer-reverse-linked-list.html"/>
      <url>/2019/02/target-offer-reverse-linked-list.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://suixinblog.cn/2019/02/linked-list.html">链表的基础知识+Python实现四种链表</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>只需要一个中间节点过渡一下就好。<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code><br>代码中，<code>last</code>指上一个反转的节点，<code>tmp</code>指当前节点的后继节点（为了赋值给当前节点完成循环），<code>pHead</code>为当前节点。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> pHead.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">while</span> pHead <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                tmp = pHead.next</span><br><span class="line">                pHead.next = last</span><br><span class="line">                last = pHead</span><br><span class="line">                pHead = tmp</span><br><span class="line">            <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure></p><p><code>运行时间：45ms</code><br><code>占用内存：5856k</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.nowcoder.com/profile/689085/codeBookDetail?submissionId=10032913" target="_blank" rel="noopener">https://www.nowcoder.com/profile/689085/codeBookDetail?submissionId=10032913</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]删除链表中重复的节点</title>
      <link href="/2019/02/target-offer-linked-list-remove-repetition.html"/>
      <url>/2019/02/target-offer-linked-list-remove-repetition.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://suixinblog.cn/2019/02/linked-list.html">链表的基础知识+Python实现四种链表</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br><a id="more"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>题目看起来挺简单的，其实做起来坑很多，需要用一点小技巧；</li><li>坑：需要完全去掉重复的节点而不是保留一个、需要返回链表头指针；</li><li>特殊输入测试：空链表、首节点重复、连续多个重复、完全重复的链表。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code></p><h3 id="解法一：加新的节点"><a href="#解法一：加新的节点" class="headerlink" title="解法一：加新的节点"></a>解法一：加新的节点</h3><ul><li>在原链表之前链一个节点<code>pre_head</code>，用它的<code>.next</code>属性返回原列表去重后的链表头指针；</li><li>使用两个指针<code>cur</code>和<code>pre</code>，分别指当前判断的节点和当前节点的前一个节点；</li><li>因为可能会出现连续重复的节点值，所以需要循环内再套循环判断。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        pre_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        pre_head.next = pHead</span><br><span class="line">        pre = pre_head</span><br><span class="line">        cur = pHead</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> cur.next.val == cur.val:</span><br><span class="line">                tmp = cur.next</span><br><span class="line">                <span class="keyword">while</span> tmp <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> tmp.val == cur.val:</span><br><span class="line">                    tmp = tmp.next</span><br><span class="line">                pre.next = tmp</span><br><span class="line">                cur = tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> pre_head.next</span><br></pre></td></tr></table></figure><p><code>运行时间：30ms</code><br><code>占用内存：5828k</code></p><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p>采用递归思想将满足一定条件的后半段链表递归地调用函数本身。详见代码注释。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="comment"># 判断链表是否为空或单节点</span></span><br><span class="line">        <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> pHead.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        real_head = pHead  <span class="comment"># real_head为原链表去重复节点之后的链表头指针</span></span><br><span class="line">        aft = pHead.next  <span class="comment"># aft为原链表的第二个节点</span></span><br><span class="line">        <span class="keyword">if</span> aft.val != real_head.val:</span><br><span class="line">            <span class="comment"># 若前两个节点不同，则real_head就是pHead。对后面的子链表递归调用</span></span><br><span class="line">            real_head.next = self.deleteDuplication(aft)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 若前两个节点相同，则需找出真正的链表头节点</span></span><br><span class="line">            tmp = aft</span><br><span class="line">            <span class="comment"># 循环向后找到与pHead不同的那个节点</span></span><br><span class="line">            <span class="keyword">while</span> tmp.val == real_head.val <span class="keyword">and</span> tmp.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                tmp = tmp.next</span><br><span class="line">            <span class="keyword">if</span> tmp.val != real_head.val:</span><br><span class="line">                <span class="comment"># 则后半段子链表的链表头为原链表的链表头（有可能再次递归，但不影响）</span></span><br><span class="line">                real_head = self.deleteDuplication(tmp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若整个链表完全重复则返回None</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> real_head</span><br></pre></td></tr></table></figure></p><p><code>运行时间：47ms</code><br><code>占用内存：5856k</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.nowcoder.com/profile/800862/codeBookDetail?submissionId=12139833" target="_blank" rel="noopener">https://www.nowcoder.com/profile/800862/codeBookDetail?submissionId=12139833</a><br><a href="https://www.nowcoder.com/profile/6935185/codeBookDetail?submissionId=12608448" target="_blank" rel="noopener">https://www.nowcoder.com/profile/6935185/codeBookDetail?submissionId=12608448</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]从尾到头打印链表</title>
      <link href="/2019/02/target-offer-reverse-print-linked-list.html"/>
      <url>/2019/02/target-offer-reverse-print-linked-list.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://suixinblog.cn/2019/02/linked-list.html">链表的基础知识+Python实现四种链表</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，按链表值从尾到头的顺序返回一个ArrayList。<br><a id="more"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>正常的思路就是先从前至后依次将链表的元素<code>append</code>到一个list中，最后再取list的逆。当然可以直接每次<code>ls.insert(0, value)</code>；</li><li>特殊输入测试：空链表。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ls = []</span><br><span class="line">        current = listNode</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            ls.append(current.val)</span><br><span class="line">            current = current.next</span><br><span class="line">        <span class="keyword">return</span> ls[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><p><code>运行时间：30ms</code><br><code>占用内存：5860k</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链表的基础知识+Python实现四种链表</title>
      <link href="/2019/02/linked-list.html"/>
      <url>/2019/02/linked-list.html</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，<strong>链表在插入或删除的时候最快可以达到O(1)的复杂度</strong>（告诉节点地址的情况下），比另一种线性表顺序表快得多，但是<strong>查找一个节点或者访问特定编号的节点则需要O(n)的时间</strong>，而顺序表相应的时间复杂度分别是O(logn)和O(1)。<br>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p></blockquote><a id="more"></a><h3 id="四种常见的链表"><a href="#四种常见的链表" class="headerlink" title="四种常见的链表"></a>四种常见的链表</h3><ol><li>单链表。每个节点只有一个属性<code>.next</code>，用于存放其后继节点；尾节点的后继为<code>None</code>；若链表为空，则头节点<code>.head</code>为<code>None</code>。</li><li>单向循环链表。每个节点只有一个属性<code>.next</code>，用于存放其后继节点；由于循环，故尾节点的后继为头节点；若链表为空，则头节点<code>.head</code>为<code>None</code>。</li><li>双向链表。每个节点有两个属性<code>.prev</code>和<code>.next</code>，分别用于存放其前驱节点和后继节点；尾节点的后继和头节点的前驱都为<code>None</code>；若链表为空，则头节点<code>.head</code>为<code>None</code>。</li><li>双向循环链表。每个节点有两个属性<code>.prev</code>和<code>.next</code>，分别用于存放其前驱节点和后继节点；由于循环，故尾节点的后继为头节点，头节点的前驱为尾节点；若链表为空，则头节点<code>.head</code>为<code>None</code>。</li></ol><h3 id="常见操作的时间复杂度"><a href="#常见操作的时间复杂度" class="headerlink" title="常见操作的时间复杂度"></a>常见操作的时间复杂度</h3><ol><li>查找：<code>O(n)</code>；</li><li>插入：<code>O(1)</code>或<code>O(n)</code>，见下；</li><li>删除：<code>O(1)</code>或<code>O(n)</code>，见下。</li></ol><ul><li><p><code>O(1)</code>的情况：</p><ul><li><p>一个已知头节点的链表，在某节点后面插入新节点，值为newdata，且告诉你该节点的地址node</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newnode = ListNode(newdata, _next=node.next)</span><br><span class="line">node.next = newnode</span><br></pre></td></tr></table></figure></li><li><p>一个已知头节点的链表，删除某节点，且告诉你该节点的地址node（思路为：将后面的节点前移一位）</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_n = node.next  <span class="comment"># node_n为需删除节点node的下一个节点</span></span><br><span class="line">node.item = node_n</span><br><span class="line">node.next = node_n.next</span><br><span class="line"><span class="keyword">del</span> node_n</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>O(n)</code>的情况（见后文代码）：</p><ul><li>一个已知头节点的链表，在第index个元素后插入一个新元素</li><li>一个已知头节点的链表，删除第index个元素或删除某个值为data的元素</li></ul></li></ul><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="单节点类"><a href="#单节点类" class="headerlink" title="单节点类"></a>单节点类</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单节点类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _item, _next=None)</span>:</span></span><br><span class="line">        self.item = _item</span><br><span class="line">        self.next = _next</span><br></pre></td></tr></table></figure><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        node = SingleListNode(newdata, _next=self.head)</span><br><span class="line">        self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        node = SingleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, newdata)</span>:</span></span><br><span class="line">        <span class="string">"""将newdata插入pos位置之后"""</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(newdata)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; self.length() - <span class="number">1</span>:</span><br><span class="line">            self.append(newdata)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = SingleListNode(newdata)</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos - <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, olddata)</span>:</span></span><br><span class="line">        <span class="string">"""从单链表中删除所有的olddata"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == olddata:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">                    self.head = cur.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回单链表的长度"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印整个单链表</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string">        ------</span></span><br><span class="line"><span class="string">        ls: list，从前至后的单链表"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        ls = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            ls.append(cur.item)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> ls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == data:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCircleLinkedList</span><span class="params">(SingleLinkedList)</span>:</span></span><br><span class="line">    <span class="string">"""单向循环链表，继承单链表类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        <span class="string">"""将新节点添加到单向循环链表头部。即头指针指向新节点，尾节点的指针指向新节点，新节点的指针指向原头节点"""</span></span><br><span class="line">        node = SingleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = self.head</span><br><span class="line">            cur.next = node</span><br><span class="line">            self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        <span class="string">"""与add方法唯一的区别为链表头的指针不变"""</span></span><br><span class="line">        node = SingleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = self.head</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, olddata)</span>:</span></span><br><span class="line">        <span class="string">"""删除一个指定的节点"""</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.head.item == olddata:</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = self.head.next</span><br><span class="line">            self.head = self.head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">                <span class="keyword">if</span> cur.item == olddata:</span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.item == olddata:</span><br><span class="line">                pre.next = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        ls = []</span><br><span class="line">        <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">            ls.append(cur.item)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        ls.append(cur.item)</span><br><span class="line">        <span class="keyword">return</span> ls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.next != self.head:</span><br><span class="line">            <span class="keyword">if</span> cur.item == data:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> cur.item == data:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="双向节点类"><a href="#双向节点类" class="headerlink" title="双向节点类"></a>双向节点类</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双向节点类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _item, _prev=None, _next=None)</span>:</span></span><br><span class="line">        self.item = _item</span><br><span class="line">        self.prev = _prev</span><br><span class="line">        self.next = _next</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span><span class="params">(SingleLinkedList)</span>:</span></span><br><span class="line">    <span class="string">"""双向链表类，继承单链表类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        node = DoubleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.next = self.head</span><br><span class="line">            self.head.prev = node</span><br><span class="line">            self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        node = DoubleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            node.prev = cur</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, newdata)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(newdata)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; self.length() - <span class="number">1</span>:</span><br><span class="line">            self.append(newdata)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = DoubleListNode(newdata)</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos - <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            node.prev = cur</span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, olddata)</span>:</span></span><br><span class="line">        <span class="string">"""删除一个指定的节点"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.head.item == olddata:</span><br><span class="line">            <span class="keyword">if</span> self.head.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                self.head = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.head.next.prev = <span class="keyword">None</span></span><br><span class="line">                self.head = self.head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> cur.item == olddata:</span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> cur.item == olddata:</span><br><span class="line">                cur.prev.next = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleCircleLinkedList</span><span class="params">(SingleCircleLinkedList)</span>:</span></span><br><span class="line">    <span class="string">"""双向循环链表类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        node = DoubleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">            node.prev = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.prev = self.head.prev</span><br><span class="line">            node.next = self.head</span><br><span class="line">            self.head.prev.next = node</span><br><span class="line">            self.head.prev = node</span><br><span class="line">            self.head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, newdata)</span>:</span></span><br><span class="line">        node = DoubleListNode(newdata)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.head = node</span><br><span class="line">            node.prev = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.head.prev.next = node</span><br><span class="line">            self.head.prev = node</span><br><span class="line">            node.prev = self.head.prev</span><br><span class="line">            node.next = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, newdata)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(newdata)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; self.length() - <span class="number">1</span>:</span><br><span class="line">            self.append(newdata)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = DoubleListNode(newdata)</span><br><span class="line">            cur = self.head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos - <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next.prev = node</span><br><span class="line">            node.prev = cur</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, olddata)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> self.head.item == olddata:</span><br><span class="line">            <span class="keyword">if</span> self.length() == <span class="number">1</span>:</span><br><span class="line">                self.head = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.head.prev.next = self.head.next</span><br><span class="line">                self.head.next.prev = self.head.prev</span><br><span class="line">                self.head = self.head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head.next</span><br><span class="line">            <span class="keyword">while</span> cur != self.head:</span><br><span class="line">                <span class="keyword">if</span> cur.item == olddata:</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    cur.next.prev = cur.prev</span><br><span class="line">                cur = cur.next</span><br></pre></td></tr></table></figure><h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_SL</span><span class="params">()</span>:</span></span><br><span class="line">    SL = SingleLinkedList()</span><br><span class="line">    print(<span class="string">'单链表是否为空：'</span>, SL.is_empty())</span><br><span class="line">    SL.add(<span class="number">1</span>)</span><br><span class="line">    SL.add(<span class="number">2</span>)</span><br><span class="line">    SL.append(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'单链表为：'</span>, SL.travel())</span><br><span class="line">    SL.insert(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'单链表中是否有4：'</span>, SL.search(<span class="number">4</span>))</span><br><span class="line">    print(<span class="string">'单链表为：'</span>, SL.travel())</span><br><span class="line">    print(<span class="string">'单链表长度：'</span>, SL.length())</span><br><span class="line">    SL.remove(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'单链表为：'</span>, SL.travel())</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_SCL</span><span class="params">()</span>:</span></span><br><span class="line">    SCL = SingleCircleLinkedList()</span><br><span class="line">    print(<span class="string">'单循环链表是否为空：'</span>, SCL.is_empty())</span><br><span class="line">    SCL.add(<span class="number">1</span>)</span><br><span class="line">    SCL.add(<span class="number">2</span>)</span><br><span class="line">    SCL.append(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'单循环链表为：'</span>, SCL.travel())</span><br><span class="line">    print(<span class="string">"在第二个节点之后插入节点'3'"</span>)</span><br><span class="line">    SCL.insert(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'单循环链表为：'</span>, SCL.travel())</span><br><span class="line">    print(<span class="string">'单循环链表中是否有4：'</span>, SCL.search(<span class="number">4</span>))</span><br><span class="line">    print(<span class="string">'单循环链表长度：'</span>, SCL.length())</span><br><span class="line">    print(<span class="string">"删除节点'5'"</span>)</span><br><span class="line">    SCL.remove(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'单循环链表为：'</span>, SCL.travel())</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_DL</span><span class="params">()</span>:</span></span><br><span class="line">    DL = DoubleLinkedList()</span><br><span class="line">    print(<span class="string">'双向链表是否为空：'</span>, DL.is_empty())</span><br><span class="line">    DL.add(<span class="number">1</span>)</span><br><span class="line">    DL.add(<span class="number">2</span>)</span><br><span class="line">    DL.append(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'双向链表为：'</span>, DL.travel())</span><br><span class="line">    print(<span class="string">"在第二个节点之后插入节点'3'"</span>)</span><br><span class="line">    DL.insert(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'双向链表为：'</span>, DL.travel())</span><br><span class="line">    print(<span class="string">'双向链表中是否有4：'</span>, DL.search(<span class="number">4</span>))</span><br><span class="line">    print(<span class="string">'双向链表长度：'</span>, DL.length())</span><br><span class="line">    print(<span class="string">"删除节点'1'"</span>)</span><br><span class="line">    DL.remove(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'双向链表为：'</span>, DL.travel())</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_DCL</span><span class="params">()</span>:</span></span><br><span class="line">    DCL = DoubleCircleLinkedList()</span><br><span class="line">    print(<span class="string">'双向循环链表是否为空：'</span>, DCL.is_empty())</span><br><span class="line">    DCL.add(<span class="number">1</span>)</span><br><span class="line">    DCL.add(<span class="number">2</span>)</span><br><span class="line">    DCL.append(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'双向循环链表为：'</span>, DCL.travel())</span><br><span class="line">    print(<span class="string">"在第二个节点之后插入节点'3'"</span>)</span><br><span class="line">    DCL.insert(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'双向循环链表为：'</span>, DCL.travel())</span><br><span class="line">    print(<span class="string">'双向循环链表中是否有10：'</span>, DCL.search(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">'双向循环链表长度：'</span>, DCL.length())</span><br><span class="line">    print(<span class="string">"删除节点'1'"</span>)</span><br><span class="line">    DCL.remove(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'双向循环链表为：'</span>, DCL.travel())</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">维基百科：链表</a><br><a href="https://github.com/Jack-Lee-Hiter/AlgorithmsByPython/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md#%E7%BA%BF%E6%80%A7%E8%A1%A8" target="_blank" rel="noopener">数据结构：线性表</a><br><a href="https://segmentfault.com/a/1190000014484156" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014484156</a><br><a href="https://www.jianshu.com/p/06a0e3c433c6" target="_blank" rel="noopener">https://www.jianshu.com/p/06a0e3c433c6</a><br><a href="https://www.cnblogs.com/Lin-Yi/p/7326713.html" target="_blank" rel="noopener">https://www.cnblogs.com/Lin-Yi/p/7326713.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]数组中重复的数字</title>
      <link href="/2019/02/target-offer-repeating-digits.html"/>
      <url>/2019/02/target-offer-repeating-digits.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><a id="more"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span><span class="params">(self, numbers, duplication)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> idx, digit <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            <span class="keyword">if</span> digit <span class="keyword">in</span> numbers[idx + <span class="number">1</span>:]:</span><br><span class="line">                duplication[<span class="number">0</span>] = digit</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p><code>运行时间：25ms</code><br><code>占用内存：5732k</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]替换空格</title>
      <link href="/2019/02/target-offer-replace-space.html"/>
      <url>/2019/02/target-offer-replace-space.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><a id="more"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(s, str):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        s_new = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">' '</span>:</span><br><span class="line">                s_new += <span class="string">'%20'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_new += i</span><br><span class="line">        <span class="keyword">return</span> s_new</span><br></pre></td></tr></table></figure></p><p><code>运行时间：25ms</code><br><code>占用内存：5736k</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[剑指Offer]二维数组中的查找</title>
      <link href="/2019/02/target-offer-array-find.html"/>
      <url>/2019/02/target-offer-array-find.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><a id="more"></a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目中说了是二维数组和整数，所以不需要考虑非法输入（包含字符串等）；但需要判断二维数组是否为空。<br>从每行最后一个数判断起，相等直接返回<code>True</code>，小于就循环到下一行，大于就在该行查找，全部找完没找到就返回<code>False</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Python(2.7.3)</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> array:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> row:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> row[<span class="number">-1</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> row[<span class="number">-1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> col <span class="keyword">in</span> row[:<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> col == target:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><p><code>运行时间：343ms</code><br><code>占用内存：5836k</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 剑指Offer </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python中dict的值为list的问题</title>
      <link href="/2019/02/python-dict-list-trouble.html"/>
      <url>/2019/02/python-dict-list-trouble.html</url>
      
        <content type="html"><![CDATA[<p>本质上，如果你设置一个dict的值为list，那么你大概率是想该dict的键能够映射多个值，并且能够不断的增添、删除或者修改。<br>Python中list的操作总是简单的，所以很多时候我都将容器设置为list，而在这次操作中，却踩了坑。<br><a id="more"></a></p><h2 id="dict的值为list的坑"><a href="#dict的值为list的坑" class="headerlink" title="dict的值为list的坑"></a>dict的值为list的坑</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info_keys = [<span class="string">'NAME'</span>, <span class="string">'AGE'</span>, <span class="string">'SEX'</span>]</span><br><span class="line">info_all = dict.fromkeys(info_keys, [])</span><br><span class="line">info = &#123;<span class="string">'NAME'</span>: <span class="string">'Tom'</span>, <span class="string">'AGE'</span>: <span class="number">22</span>, <span class="string">'SEX'</span>: <span class="string">'F'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info_keys:</span><br><span class="line">    info_all[key].append(info[key])</span><br><span class="line">print(info_all)</span><br></pre></td></tr></table></figure><p>输出却为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'NAME'</span>: [<span class="string">'Tom'</span>, 22, <span class="string">'F'</span>], <span class="string">'AGE'</span>: [<span class="string">'Tom'</span>, 22, <span class="string">'F'</span>], <span class="string">'SEX'</span>: [<span class="string">'Tom'</span>, 22, <span class="string">'F'</span>]&#125;</span><br></pre></td></tr></table></figure></p><p><strong>为什么？</strong><br>事实上，使用<code>fromkeys()</code>后，所有键都指向同一个值，可使用<code>id()</code>函数查看字典三个键的内存地址均相同：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(id(info_all[<span class="string">'NAME'</span>]), id(info_all[<span class="string">'AGE'</span>]), id(info_all[<span class="string">'SEX'</span>]))</span><br><span class="line">4507619272 4507619272 4507619272</span><br></pre></td></tr></table></figure></p><h2 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info_keys = [<span class="string">'NAME'</span>, <span class="string">'AGE'</span>, <span class="string">'SEX'</span>]</span><br><span class="line">info_all = &#123;<span class="string">'NAME'</span>: [], <span class="string">'AGE'</span>: [], <span class="string">'SEX'</span>: []&#125;</span><br><span class="line">info = &#123;<span class="string">'NAME'</span>: <span class="string">'Tom'</span>, <span class="string">'AGE'</span>: <span class="number">22</span>, <span class="string">'SEX'</span>: <span class="string">'F'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info_keys:</span><br><span class="line">    info_all[key].append(info[key])</span><br><span class="line">print(info_all)</span><br></pre></td></tr></table></figure><p>此时：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(id(info_all[<span class="string">'NAME'</span>]), id(info_all[<span class="string">'AGE'</span>]), id(info_all[<span class="string">'SEX'</span>]))</span><br><span class="line">4419928008 4420628360 4420627528</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info_keys = [<span class="string">'NAME'</span>, <span class="string">'AGE'</span>, <span class="string">'SEX'</span>]</span><br><span class="line">info_all = &#123;&#125;</span><br><span class="line">info = &#123;<span class="string">'NAME'</span>: <span class="string">'Tom'</span>, <span class="string">'AGE'</span>: <span class="number">22</span>, <span class="string">'SEX'</span>: <span class="string">'F'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info_keys:</span><br><span class="line">    info_all.setdefault(key, []).append(info[key])</span><br><span class="line">print(info_all)</span><br></pre></td></tr></table></figure></p><p>均能正确输出结果：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'NAME'</span>: [<span class="string">'Tom'</span>], <span class="string">'AGE'</span>: [22], <span class="string">'SEX'</span>: [<span class="string">'F'</span>]&#125;</span><br></pre></td></tr></table></figure></p><p>此时：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(id(info_all[<span class="string">'NAME'</span>]), id(info_all[<span class="string">'AGE'</span>]), id(info_all[<span class="string">'SEX'</span>]))</span><br><span class="line">4317806536 4318506888 4318506056</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p06_map_keys_to_multiple_values_in_dict.html" target="_blank" rel="noopener">https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p06_map_keys_to_multiple_values_in_dict.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> dict </tag>
            
            <tag> list </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python处理Excel文件(csv, xls, xlsx)</title>
      <link href="/2019/02/python-excel.html"/>
      <url>/2019/02/python-excel.html</url>
      
        <content type="html"><![CDATA[<p>Excel文件格式主要有csv，xlsx和xlsx，对于不同的格式，我们使用不同的包来进行处理。<br><a id="more"></a></p><h2 id="使用csv包处理csv文件"><a href="#使用csv包处理csv文件" class="headerlink" title="使用csv包处理csv文件"></a>使用<code>csv</code>包处理csv文件</h2><h3 id="读取csv文件"><a href="#读取csv文件" class="headerlink" title="读取csv文件"></a>读取csv文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./data.csv'</span>, <span class="string">'r'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamreader = csv.reader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> spamreader:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure><p>其中，<code>encoding=&#39;utf-8-sig&#39;</code>是为了编码正常可以正确显示中文，<code>spamreader</code>中的每一个<code>row</code>为list格式，可以循环取出每个单元格的值。</p><h3 id="写入csv文件"><a href="#写入csv文件" class="headerlink" title="写入csv文件"></a>写入csv文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./data.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8-sig'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamwriter = csv.writer(csvfile)</span><br><span class="line">    spamwriter.writerow([<span class="string">'HELLO'</span>, <span class="string">'WORLD'</span>])</span><br><span class="line">    spamwriter.writerows([(<span class="string">'SuiXin'</span>, <span class="string">'Blog'</span>), (<span class="string">'https://suixinblog.cn'</span>, <span class="string">'2019'</span>, <span class="string">'CSV'</span>, <span class="string">'文件'</span>)])</span><br></pre></td></tr></table></figure><p>结果：</p><center><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g09fuqu5arj30jc07gmz8.jpg" width="50%" alt="写入csv文件"></center><p><strong>注</strong>：使用delimiter参数来指定数据的分隔符，默认为<code>,</code>。</p><h3 id="使用pandas包读写csv数据文件"><a href="#使用pandas包读写csv数据文件" class="headerlink" title="使用pandas包读写csv数据文件"></a>使用<code>pandas</code>包读写csv数据文件</h3><p>如果csv文件是数据类的，那么使用<code>pandas</code>包读写数据会更方便。</p><h4 id="读取csv数据存入DataFrame对象中"><a href="#读取csv数据存入DataFrame对象中" class="headerlink" title="读取csv数据存入DataFrame对象中"></a>读取csv数据存入DataFrame对象中</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">"hou_all.csv"</span>, header=<span class="keyword">None</span>, names=[<span class="string">"CRIM"</span>, <span class="string">"ZN"</span>, <span class="string">"INDUS"</span>, <span class="string">"CHAS"</span>, <span class="string">"NOX"</span>, <span class="string">"RM"</span>, <span class="string">"AGE"</span>, <span class="string">"DIS"</span>, <span class="string">"RAD"</span>, <span class="string">"TAX"</span>, <span class="string">"PTRATIO"</span>, <span class="string">"B"</span>, <span class="string">"LSTAT"</span>, <span class="string">"MEDV"</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g09gejml7kj31qk0e00w9.jpg" alt=""><br>参数：</p><ul><li><code>sep=&#39;,&#39;</code>：str，分隔符；</li><li><code>header=0</code>：int，指定行数用作列名。如果文件不包含列名可以设置为<code>None</code>；</li><li><code>names</code>：array-like，指定列名。相当于对没有列名的DataFrame设置<code>df.columns</code>；</li><li><code>squeeze=False</code>：bool，如果文件值包含一列，返回一个Series；</li><li><code>prefix</code>：str，在没有列名时，给列添加前缀。如：<code>prefix=&#39;V&#39;</code>则列名为<code>V0</code>，<code>V1</code>，<code>V2</code>……</li><li><code>skiprows=None</code>：list-like or int，需要忽略的行数；</li><li><code>nrows=None</code>：int，需要读取的行数；</li><li><code>skip_blank_lines=True</code>：bool，是否跳过空行。</li></ul><h4 id="将数据写入csv文件"><a href="#将数据写入csv文件" class="headerlink" title="将数据写入csv文件"></a>将数据写入csv文件</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'NAME'</span>: [<span class="string">'TOM'</span>, <span class="string">'SuiXin'</span>], <span class="string">'AGE'</span>: [<span class="number">12</span>, <span class="number">24</span>]&#125;</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line">print(df)</span><br><span class="line">df.to_csv(<span class="string">'data1.csv'</span>, index=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><center><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g09gxbdk5ej30c405yq45.jpg" width="35%" alt="pandas写入csv数据"></center><p>参数：</p><ul><li><code>sep=&#39;,&#39;</code>：str，分隔符；</li><li><code>na_rep=&#39;&#39;</code>：str，缺失值表示；</li><li><code>float_format=None</code>：str，浮点数格式。如<code>float_format=&#39;%.2f&#39;</code>；</li><li><code>columns</code>：sequence，需要写入的列；</li><li><code>header=True</code>：bool，list of str，写入列名；</li><li><code>index=True</code>：bool，写入行名。</li></ul><h2 id="使用openpyxl包处理xlsx文件"><a href="#使用openpyxl包处理xlsx文件" class="headerlink" title="使用openpyxl包处理xlsx文件"></a>使用<code>openpyxl</code>包处理xlsx文件</h2><p>Excel文件有三层对象：工作薄、工作表和三元格，分别对应<code>openpyxl</code>包中的workbook、sheet和cell。</p><h3 id="workbook操作"><a href="#workbook操作" class="headerlink" title="workbook操作"></a>workbook操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取xlsx文件</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'test.xlsx'</span>)</span><br><span class="line"><span class="comment"># 以只读模式读取</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'test.xlsx'</span>, read_only=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 新建一个工作薄</span></span><br><span class="line">wb = openpyxl.Workbook()</span><br><span class="line"><span class="comment"># 保存xlsx文件</span></span><br><span class="line">wb.save(<span class="string">'test.xlsx'</span>)</span><br></pre></td></tr></table></figure><h3 id="sheet操作"><a href="#sheet操作" class="headerlink" title="sheet操作"></a>sheet操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取工作薄所有的sheet，返回list</span></span><br><span class="line">sheets = wb.worksheets</span><br><span class="line"><span class="comment"># 获取指定sheet页</span></span><br><span class="line">ws = wb[<span class="string">'标记数据'</span>]</span><br><span class="line">ws = wb.worksheets[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获取当前正在使用的sheet页</span></span><br><span class="line">ws = wb.active</span><br><span class="line"><span class="comment"># sheet页属性：表名、最大行数、最大列数</span></span><br><span class="line">print(ws.title, ws.max_row, ws.max_column)</span><br><span class="line"><span class="comment"># 修改sheet名</span></span><br><span class="line">ws.title = <span class="string">'标记数据2'</span></span><br><span class="line"><span class="comment"># 删除sheet页</span></span><br><span class="line">wb.remove(ws)</span><br><span class="line"><span class="keyword">del</span> wb[<span class="string">'标记数据'</span>]</span><br><span class="line"><span class="comment"># 新建sheet页（可以插入到指定的索引处）</span></span><br><span class="line">wb.create_sheet(<span class="string">'test1'</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="sheet属性"><a href="#sheet属性" class="headerlink" title="sheet属性"></a>sheet属性</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取行和列，返回tuple</span></span><br><span class="line">ws[<span class="number">1</span>]</span><br><span class="line">ws[<span class="string">'A'</span>]</span><br><span class="line"><span class="comment"># 对行或列切片，返回tuple</span></span><br><span class="line">ws[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">ws[<span class="string">'A:D'</span>]</span><br><span class="line"><span class="comment"># 获取所有行或列，返回generator</span></span><br><span class="line">rows = ws.rows</span><br><span class="line">columns = ws.columns</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> row:</span><br><span class="line">        print(i.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一行值（添加多行值直接循环添加即可）</span></span><br><span class="line">ws.append([<span class="string">'人民法院'</span>, <span class="string">'故意伤害罪'</span>, <span class="string">'89f01654'</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 添加一列值（添加多列值只需将s改为多层list嵌套，其中每一个list为一列）</span></span><br><span class="line">s = [[<span class="string">'NAME'</span>, <span class="string">'Make'</span>, <span class="string">'Tom'</span>, <span class="string">'Smith'</span>, <span class="string">'Suixin'</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(*s):</span><br><span class="line">    ws.append(i)</span><br></pre></td></tr></table></figure><h3 id="cell操作"><a href="#cell操作" class="headerlink" title="cell操作"></a>cell操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取cell</span></span><br><span class="line">cell = ws[<span class="string">'B3'</span>]</span><br><span class="line">cell = ws.cell(<span class="number">3</span>, <span class="number">2</span>)  <span class="comment"># 先行坐标后列坐标（均从1开始）</span></span><br><span class="line"><span class="comment"># cell属性：所在行、列、坐标、值</span></span><br><span class="line">print(cell.row, cell.column, cell.coordinate, cell.value)</span><br><span class="line"><span class="comment"># 写入cell</span></span><br><span class="line">cell.value = <span class="string">'NAME'</span></span><br><span class="line">ws[<span class="string">'B3'</span>] = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p><strong>注</strong>：<code>openpyxl</code>功能全面，还支持：合并单元格、数学运算、单元格格式、迭代器<code>ws.iter_rows()</code>操作等。</p><h2 id="使用xlrd，xlwt和xlutils包处理xls文件"><a href="#使用xlrd，xlwt和xlutils包处理xls文件" class="headerlink" title="使用xlrd，xlwt和xlutils包处理xls文件"></a>使用<code>xlrd</code>，<code>xlwt</code>和<code>xlutils</code>包处理xls文件</h2><h3 id="使用xlrd读取xls文件"><a href="#使用xlrd读取xls文件" class="headerlink" title="使用xlrd读取xls文件"></a>使用<code>xlrd</code>读取xls文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开已有的工作薄</span></span><br><span class="line">wb = xlrd.open_workbook(<span class="string">'test.xls'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的sheet名称</span></span><br><span class="line">sheet_names = wb.sheet_names()</span><br><span class="line"><span class="comment"># 获得sheet对象</span></span><br><span class="line">ws = wb.sheet_by_index(<span class="number">0</span>)</span><br><span class="line">ws = wb.sheet_by_name(<span class="string">'标记数据'</span>)</span><br><span class="line"><span class="comment"># 获取sheet对象的属性：表名、总行数、总列数</span></span><br><span class="line">print(ws.name, ws.nrows, ws.ncols)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得某一行或某一列数据，返回list</span></span><br><span class="line">row_4 = ws.row_values(<span class="number">3</span>)</span><br><span class="line">cloumn_5 = ws.col_values(<span class="number">4</span>)</span><br><span class="line">Row_4 = ws.row(<span class="number">3</span>)  <span class="comment"># 此方法list中包含单元格类型</span></span><br><span class="line">Column_5 = ws.col(<span class="number">4</span>)  <span class="comment"># 此方法list中包含单元格类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得某一单元格的值</span></span><br><span class="line">cell_1_1 = ws.cell_value(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">cell_1_1 = ws.cell(<span class="number">0</span>, <span class="number">0</span>).value</span><br><span class="line">cell_1_1 = ws.row_values(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">cell_1_1 = ws.col_values(<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">cell_1_1 = ws.row(<span class="number">0</span>)[<span class="number">0</span>].value</span><br><span class="line">cell_1_1 = ws.col(<span class="number">0</span>)[<span class="number">0</span>].value</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<code>xlrd</code>打开为只读模式，不可修改。</p><h3 id="使用xlwt写入新建的xls文件"><a href="#使用xlwt写入新建的xls文件" class="headerlink" title="使用xlwt写入新建的xls文件"></a>使用<code>xlwt</code>写入新建的xls文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的工作薄</span></span><br><span class="line">wb = xlwt.Workbook(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="comment"># 在其上创建一个新的工作表</span></span><br><span class="line">ws = wb.add_sheet(<span class="string">'S1'</span>, cell_overwrite_ok=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按单元格方式添加数据</span></span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'HELLO'</span>)</span><br><span class="line"><span class="comment"># 整行整列的添加数据</span></span><br><span class="line">title = [<span class="string">'NAME'</span>, <span class="string">'AGE'</span>, <span class="string">'SEX'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(title)):</span><br><span class="line">    ws.write(<span class="number">0</span>, i, title[i])</span><br><span class="line">name = [<span class="string">'Tom'</span>, <span class="string">'Smith'</span>, <span class="string">'SuiXin'</span>, <span class="string">'Make'</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(name)):</span><br><span class="line">    ws.write(j + <span class="number">1</span>, <span class="number">0</span>, name[j])</span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">wb.save(<span class="string">'test.xls'</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><center><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g09nc6aacdj30ca06qgn2.jpg" ,="" width="40%" alt="xlwt写入xls文件"></center><h3 id="使用xlutils修改xls文件"><a href="#使用xlutils修改xls文件" class="headerlink" title="使用xlutils修改xls文件"></a>使用<code>xlutils</code>修改xls文件</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> xlutils.copy <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">rd_book = xlrd.open_workbook(<span class="string">'test.xls'</span>)</span><br><span class="line"><span class="comment"># 使用copy方法将xlrd.Book对象拷贝为一个xlwt.workbook对象，可写入</span></span><br><span class="line">wt_book = copy(rd_book)</span><br><span class="line"><span class="comment"># 获取一个sheet对象（支持index和name）</span></span><br><span class="line">ws = wt_book.get_sheet(<span class="string">'S1'</span>)</span><br><span class="line"><span class="comment"># 修改工作表</span></span><br><span class="line">age = [<span class="number">32</span>, <span class="number">38</span>, <span class="number">24</span>, <span class="number">40</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(age)):</span><br><span class="line">    ws.write(j + <span class="number">1</span>, <span class="number">1</span>, age[j])</span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">wt_book.save(<span class="string">'test_new.xls'</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><center><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g09not5lyrj30du062myn.jpg" ,="" width="50%" alt="xlutils修改xls文件"></center><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://juejin.im/entry/5b3b2c7d6fb9a04fe820c5a3" target="_blank" rel="noopener">https://juejin.im/entry/5b3b2c7d6fb9a04fe820c5a3</a><br><a href="https://blog.csdn.net/sinat_28576553/article/details/81275650" target="_blank" rel="noopener">https://blog.csdn.net/sinat_28576553/article/details/81275650</a><br><a href="https://zhuanlan.zhihu.com/p/35605282" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35605282</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Python处理json文件</title>
      <link href="/2019/02/python-json.html"/>
      <url>/2019/02/python-json.html</url>
      
        <content type="html"><![CDATA[<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，尽管JSON是JavaScript的一个子集，但它是独立于语言的文本格式。<br>在Python中，我们使用<code>json</code>包来实现json文件的读取和写入。<br><a id="more"></a></p><h2 id="读取json文件"><a href="#读取json文件" class="headerlink" title="读取json文件"></a>读取json文件</h2><p>使用<code>json.loads()</code>或<code>json.load()</code>两个函数来读取json文件。</p><h3 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads()"></a><code>json.loads()</code></h3><p><code>json.loads()</code>用来解析包含JSON数据的字符串，解析后变量格式为字典。<br>用法：</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzs3tggakvj310o06gtbp.jpg" ,="" width="50%" alt="json.loads()用法"></center></p><h3 id="json-load"><a href="#json-load" class="headerlink" title="json.load()"></a><code>json.load()</code></h3><p><code>json.load()</code>用来解析json文件，这也是和<code>json.loads()</code>唯一的区别。<br>解析json文件时，要么该文件只包含一行（只有一个字典），要么每个字典是列表的一个元素，如图：</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzs5m8jkf4j30pk03wgmd.jpg" ,="" width="50%" alt="json.load()用法"></center><br>如果是后一种，则解析出的变量也为列表格式，每个元素是对应的字典。</p><h2 id="编码为json格式"><a href="#编码为json格式" class="headerlink" title="编码为json格式"></a>编码为json格式</h2><p>使用<code>json.dumps()</code>或<code>json.dump()</code>两个函数来编码json格式。</p><h3 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps()"></a><code>json.dumps()</code></h3><p><code>json.dumps()</code>将一个Python数据结构（字典）编码成json格式的字符串。<br>用法：</p><p><center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzs65ln3v9j30wi06g41a.jpg" ,="" width="50%" alt="json.dumps()用法"></center></p><h3 id="json-dump"><a href="#json-dump" class="headerlink" title="json.dump()"></a><code>json.dump()</code></h3><p><code>json.dump()</code>将一个Python数据结构（字典）编码成json格式，并写入到文件中。<br>用法：</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzs6nisyd6j30vq05cmzb.jpg" ,="" width="50%" alt="json.dump()用法"></center><br><code>jj.json</code>文件为：</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzs6nsw1xsj30o401it8u.jpg" ,="" width="50%" alt="写入的json文件"></center></p><h3 id="共有参数"><a href="#共有参数" class="headerlink" title="共有参数"></a>共有参数</h3><ul><li><code>ensure_ascii=True</code>：如果有中文时，需改为False，即不转义为ASCII码；</li><li><code>indent=None</code>：缩进。默认为紧凑格式，0/负数或者<code>&quot;&quot;</code>为只换行，正数代表缩进多少个空格，也可以使用<code>&quot;\t&quot;</code>等；</li><li><code>sort_keys=False</code>：是否按照键排序；</li><li><code>separators=None</code>：分隔符。默认为<code>None</code>（即<code>(&quot;, &quot;, &quot;: &quot;)</code>），可以改为紧凑形式<code>(&quot;,&quot;, &quot;:&quot;)</code>等。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The Transformer</title>
      <link href="/2019/01/transformer.html"/>
      <url>/2019/01/transformer.html</url>
      
        <content type="html"><![CDATA[<p>Transformer是个叠加的“自注意力机制（Self Attention）”构成的深度网络，是目前NLP里最强的特征提取器。<br>论文：<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention Is All You Need</a><br><a id="more"></a></p><h2 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h2><p>整体上还是由Encoders和Decoders两部分组成的，而每一个部分是由6个Encoder和Decoder堆栈成的，每个的结构完全相同，但不共享权重。</p><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>每个Encoder由两部分组成：Multi-head self-attention层和Feed Forward NN层。</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>每个Decoder由三部分组成：Multi-head self-attention层，Encoder-Decoder Attention层和Feed Forward NN层。</p><h2 id="模型细节"><a href="#模型细节" class="headerlink" title="模型细节"></a>模型细节</h2><h3 id="Encoder-1"><a href="#Encoder-1" class="headerlink" title="Encoder"></a>Encoder</h3><h4 id="self-attention"><a href="#self-attention" class="headerlink" title="self-attention"></a>self-attention</h4><p>动机：当模型处理每个单词（输入序列中的每个位置）时，self-attention允许它查看输入序列中的其他位置以寻找可以帮助导致对该单词更好的编码的线索。</p><ol><li>每个单词除了本身的Embedding向量$x$都对应三个向量，分别有不同的用处：Query向量$q$，Key向量$k$和Value向量$v$。维数一般低于单词的嵌入向量，论文中使用64（Embedding为512维）。这三个向量分别是在训练过程中将Embedding向量$x$乘以三个矩阵$W^Q$，$W^K$和$W^V$得到。</li><li>我们需要根据当前编码的单词对输入句子的每个单词进行评分，分数决定了对输入句子的其他部分放置多少焦点。通过将当前单词的Query向量与其它单词的Key向量做内积计算得分。</li><li>将得分除以8（论文中使用Key向量维数的平方根）。可以使得梯度更稳定？</li><li>softmax层将所有的分值变为概率值。</li><li>用softmax概率值乘以Value向量。直观解释：保持想要关注的值更大，不想关注的单词被淹没掉。</li><li>对上面得到的向量求和得到当前编码单词的self-attention输出向量$z$。</li></ol><p>使用矩阵形式可以并行计算。<br><strong>图示</strong>：</p><center><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz9wzpgnsxj30g50iaaat.jpg" ,="" alt="self-attention矩阵形式1" width="30%"></center><center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz9wzvwzxgj30ot09p3yw.jpg" ,="" alt="self-attention矩阵形式2" width="50%"></center><h4 id="Multi-head"><a href="#Multi-head" class="headerlink" title="Multi-head"></a>Multi-head</h4><p>动机：将信息映射到不同的子空间，可能会抓取到不同位置的注意信息。<br>按照self-attention方式进行相同的几次计算（论文中使用8头），每次使用不同的权重矩阵（$W^Q$，$W^K$和$W^V$），最终会得到几个不同的$Z$矩阵，将它们直接拼接起来得到一个很长的矩阵$Z$，再乘以一个参数矩阵$W^O$将矩阵压缩到低维（同Embedding维数）。</p><h4 id="Position-encoding"><a href="#Position-encoding" class="headerlink" title="Position encoding"></a>Position encoding</h4><p>单词顺序是NLP中非常重要的信息，所以加入Position encoding是考虑输入序列中单词顺序的一种方法。将位置编码与Embedding向量直接加起来得到真正的单词输入向量。<br>论文中给出了两个位置编码公式：</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzajx9mh42j30kw0420tb.jpg" ,="" alt="Position encoding公式" width="40%"></center><p>此处，pos是当前单词所处的位置，$2i/2i+1$是Position encoding的维度信息（如第一个单词的第一维位置编码值为$PE_{(0,2\times0)}=sin(0/10000^{2\times0/512})=0$，pos和维度都是从0开始。<em>参考1中Position Encoding算错了</em>）。使用这个正弦余弦的公式的优点是可以扩展到序列长度大于训练模型中任意长度的情况。</p><h4 id="Feed-Forward-NN层"><a href="#Feed-Forward-NN层" class="headerlink" title="Feed Forward NN层"></a>Feed Forward NN层</h4><p>该层为简单的全连接层，使用了RELU激活函数，论文中该全连接的隐藏层维数为2048，公式如下：</p><center><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzaqej0qupj30k8028aa8.jpg" ,="" alt="Feed Forward NN层公式" width="40%"></center><h4 id="Add-amp-Norm"><a href="#Add-amp-Norm" class="headerlink" title="Add &amp; Norm"></a>Add &amp; Norm</h4><p>在每一个子层的结束，输出矩阵为$Z$，我们将该层的输入矩阵$X$和$Z$直接相加，再做Normalize操作$LayerNorm(X+Z)$，该Norm函数引用了<a href="https://arxiv.org/pdf/1607.06450.pdf" target="_blank" rel="noopener">参考文献1: Layer Normalization</a>。<br>Norm方法有很多，但它们都有一个共同的目的，那就是把输入转化成均值为0方差为1的数据。我们在把数据送入激活函数之前进行normalization，因为我们不希望输入数据落在激活函数的饱和区。</p><h4 id="总架构图"><a href="#总架构图" class="headerlink" title="总架构图"></a>总架构图</h4><center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzaqigx5gwj30js0ii0ur.jpg" ,="" alt="Encoder总架构图" width="50%"></center><p><strong>真正的Encoders由N（论文中N=6）个相同的Encoder堆栈而成</strong></p><h3 id="Decoder-1"><a href="#Decoder-1" class="headerlink" title="Decoder"></a>Decoder</h3><ol><li>由Encoder最后的输出矩阵变换得到两个Attention矩阵$K_{encoder}$和$V_{encoder}$，分别输入到每个Encoder-Decoder Attention层，需使用时直接查询其中的Key向量和Value向量。这有助于解码器关注输入序列中的适当位置。而此层的Query向量则由之前的Decoder层得到。</li><li>在每一次Decoders解码一个单词的时候，整个模型的输入有三个：网络底层输入上一个解码出单词的embedding向量，在Encoder-Decoder层输入Encoders最后输出的两个矩阵$K_{encoder}$和$V_{encoder}$。使用上一个解码出的单词embedding向量传到Decoders最底层过一遍Masked Multi-head Attention，最后输出一个向量，再用这个向量生成Query向量以供中间的Encoder-Decoder Attention层使用。</li><li>只有第一个Decoder需要上一个解码出单词的embedding向量信息，后面的几个Decoder直接将上一个Decoder的输出作为Masked Multi-head Attention的输入。</li><li>每一个Decoder也都和Encoder一样使用了Add &amp; Norm以及Position encoding。</li></ol><h4 id="Linear层和softmax层"><a href="#Linear层和softmax层" class="headerlink" title="Linear层和softmax层"></a>Linear层和softmax层</h4><p>该层是一个简单的全连接网络，将最后一个Decoder输出的向量投影到一个更高维度的空间去（词典维数）。<br>softmax层将Linear层的输出向量转化为概率输出，选择最大概率的单词作为输出。</p><h3 id="两张有助于理解的图"><a href="#两张有助于理解的图" class="headerlink" title="两张有助于理解的图"></a>两张有助于理解的图</h3><p>Encoders最后将$K_{encoder}$和$V_{encoder}$输出给每个Decoder的Encoder-Decoder层：</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzaule5ofkj313b0mc7a2.jpg" ,="" alt="架构图" width="80%"></center>Google AI Blog做的动图：<center><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fzaujsgus8g30m80jo4ni.gif" ,="" alt="Google AI Blog动图" width="50%"></center><h3 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h3><p>Padding mask在所有的scaled dot-product attention里面都需要用到，而Sequence mask只有在Decoder的self-attention里面用到。</p><h4 id="Padding-mask"><a href="#Padding-mask" class="headerlink" title="Padding mask"></a>Padding mask</h4><p>语料库中每个句子的长度是不同的，我们需要对齐。使用我们设置的阈值（一般为255），对于较长的序列，直接截取左边的序列，对于较短的序列，在其后添加0。<br>而在scaled dot-product attention中，不能对这部分添加了0的单词位置加上较高的注意力，所以在self-attention中的softmax之前，直接将这些位置的值设为$-Inf$，经过softmax后这些位置的概率值会变为0。<br>即下图中的<code>Mask(opt.)</code>块：</p><center><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fzaustjxg4j30fw0jcq4s.jpg" ,="" alt="Padding mask" width="30%"></center><h4 id="Sequence-mask"><a href="#Sequence-mask" class="headerlink" title="Sequence mask"></a>Sequence mask</h4><p>Sequence mask是为了使得Decoder不能看见未来的信息，使得解码器的attention只能关注当前解码单词之前的输出单词，而不能依赖后面未解码出来的。<br>所以跟Padding mask一样，对其后的单词位置直接设为$-Inf$，经过softmax后这些位置的概率值会变为0。<br>这步操作对应Decoder中第一个构件：Masked Multi-head Attention。</p><h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>使用交叉熵或者KL散度去比较两个输出之间的差距，然后使用反向传播优化其中的所有参数。</p><h4 id="beam-search（束搜索）"><a href="#beam-search（束搜索）" class="headerlink" title="beam search（束搜索）"></a>beam search（束搜索）</h4><p>在最后的softmax层我们直接输出了最大值位置的单词，叫做贪婪解码。<br>另一种更合理的解码方式叫做<strong>束搜索</strong>。假设第1#位置解码出的概率值，前两大的位置单词为<code>I</code>和<code>me</code>，那么在第2#位置解码时，依赖的第1#位置单词分别取为<code>I</code>和<code>me</code>，分别跑两次算法，在其中再选两个得分最高（或误差最小）的结果，依次类推。最终会得到两个得分最高的序列。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li>主要参考: <a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a></li><li>Google AI Blog: <a href="https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html" target="_blank" rel="noopener">Transformer: A Novel Neural Network Architecture for Language Understanding</a></li><li><a href="https://www.jianshu.com/p/ef41302edeef" target="_blank" rel="noopener">神经机器翻译 之 谷歌 transformer 模型</a></li><li><a href="https://terrifyzhao.github.io/2019/01/11/Transformer%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">Transformer模型详解</a></li><li>Harvard NLP的解释和代码: <a href="http://nlp.seas.harvard.edu/2018/04/03/attention.html" target="_blank" rel="noopener">The Annotated Transformer</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python递归处理目录下的文件</title>
      <link href="/2019/01/os-walk.html"/>
      <url>/2019/01/os-walk.html</url>
      
        <content type="html"><![CDATA[<p>使用<code>os</code>模块的<code>os.walk()</code>函数可以递归地遍历目录。<br><a id="more"></a></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code><br><strong>top</strong>：要遍历的目录地址；<br><strong>topdown</strong>：遍历优先级。True为先遍历top目录，False为先遍历top子目录。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>目录结构为：</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz4vz4yrjtj30l40c4mzz.jpg" ,="" alt="目录结构" width="50%"></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">"Suixin/"</span>):</span><br><span class="line">    print(root)</span><br><span class="line">    print(dirs)</span><br><span class="line">    print(files, <span class="string">"\n\n"</span>)</span><br></pre></td></tr></table></figure><p><center><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz4w05z2avj30j3094js1.jpg"," alt="输出结果" ,="" width="60%"></center><br>可看到，函数先遍历了主目录<code>Suixin/</code>，其下有两个子目录<code>other</code>和<code>Blog</code>、两个文件<code>.DS_Store</code>和<code>code1.py</code>；再分别遍历了两个子目录<code>other</code>和<code>Blog</code>，其下无子子目录，只有文件。<br>该方法对于递归处理目录文件非常有效，而且函数运行很快，消耗极小的时间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://docs.python.org/3/library/os.html" target="_blank" rel="noopener">https://docs.python.org/3/library/os.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python打印带颜色的字符串</title>
      <link href="/2019/01/print-colorful.html"/>
      <url>/2019/01/print-colorful.html</url>
      
        <content type="html"><![CDATA[<p>可以使用Python中自带的<code>print</code>输出带有颜色或者背景的字符串。<br><a id="more"></a></p><h2 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h2><p><code>print(\033[显示方式;前景色;背景色m输出内容\033[0m)</code><br>其中，显示方式、前景色、背景色都是可选参数（可缺省一个或多个）。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="显示方式"><a href="#显示方式" class="headerlink" title="显示方式"></a>显示方式</h3><div class="table-container"><table><thead><tr><th>显示方式</th><th>效果</th></tr></thead><tbody><tr><td>0</td><td>默认</td></tr><tr><td>1</td><td>粗体</td></tr><tr><td>4</td><td>下划线</td></tr><tr><td>5</td><td>闪烁</td></tr><tr><td>7</td><td>反白显示</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"显示方式："</span>)</span><br><span class="line">print(<span class="string">"\033[0mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[1mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[4mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[5mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[7mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz4sjpfz49j30al03uwes.jpg" alt=""></p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><div class="table-container"><table><thead><tr><th>字体色编号</th><th>背景色编号</th><th>颜色</th></tr></thead><tbody><tr><td>30</td><td>40</td><td>黑色</td></tr><tr><td>31</td><td>41</td><td>红色</td></tr><tr><td>32</td><td>42</td><td>绿色</td></tr><tr><td>33</td><td>43</td><td>黄色</td></tr><tr><td>34</td><td>44</td><td>蓝色</td></tr><tr><td>35</td><td>45</td><td>紫色</td></tr><tr><td>36</td><td>46</td><td>青色</td></tr><tr><td>37</td><td>47</td><td>白色</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"字体色："</span>)</span><br><span class="line">print(<span class="string">"\033[30mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[31mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[32mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[4;33mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[34mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[1;35mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[4;36mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37mSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"背景色："</span>)</span><br><span class="line">print(<span class="string">"\033[1;37;40m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37;41m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37;42m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37;43m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37;44m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37;45m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[37;46m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br><span class="line">print(<span class="string">"\033[1;30;47m\tSuixinBlog: https://suixinblog.cn\033[0m"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fz4sv8ele2j30d00bktab.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.csdn.net/qq_34857250/article/details/79673698" target="_blank" rel="noopener">https://blog.csdn.net/qq_34857250/article/details/79673698</a><br><a href="https://www.cnblogs.com/fangbei/p/python-print-color.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangbei/p/python-print-color.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux文件权限管理命令chmod</title>
      <link href="/2018/12/chmod.html"/>
      <url>/2018/12/chmod.html</url>
      
        <content type="html"><![CDATA[<p>经常会用到命令诸如<code>chmod +x anaconda3.sh</code>之类的命令，今天对Linux文件的权限做总结。<br><a id="more"></a></p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>在某文件夹查看文件时输入<code>ls -l</code>可看到如下图：<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fya0fheqcdj31ew0u0b0x.jpg" alt=""><br>图中第一列即为文件的权限信息，第二列为连接的文件数，第三列为文件属主，第四列为文件属组，第五列为文件大小（字节），后面三列为文件的最后修改时间，最后为文件的名称。<br>在文件的权限信息中，第一个字母为：</p><ul><li><code>-</code>：普通文件；</li><li><code>d</code>：文件夹；</li><li><code>l</code>：链接文件。</li></ul><p>后面九个字母分为三组，分别为文件属主（u）、与文件属主同组的其他用户（g）、其他用户的权限（o）。每一组中分别有三个位置，分别表示意思如下：</p><ul><li><code>r</code>：可读取；</li><li><code>w</code>：可写入；</li><li><code>x</code>：可执行；</li><li><code>-</code>：空。</li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>Linux中使用<code>chmod</code>命令来修改文件的权限。<br>用法：<code>chmod [ugoa][+-=][rwx] &lt;file&gt;</code></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>设置对象：<ul><li><code>u</code>：对文件属主设置；</li><li><code>g</code>：对与文件属主同组的其他用户设置；</li><li><code>o</code>：对其他用户设置；</li><li><code>a</code>：对所有用户设置（缺省）。</li></ul></li><li>权限操作：<ul><li><code>+</code>：增加权限；</li><li><code>-</code>：取消权限；</li><li><code>=</code>：指定权限（后跟<code>rwx</code>直接指定，不保留原来的权限）。</li></ul></li></ul><h3 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h3><p>用三位数字直接设定三种对象的权限。<br>权限与数字对应关系：</p><ul><li><code>r</code>：4；</li><li><code>w</code>：2；</li><li><code>x</code>：1；</li><li><code>-</code>：0</li></ul><p>将想设置的权限对应数字加起来可得一个从0到7的数字，即为对应权限。<br>如想对<code>u</code>和<code>g</code>设置读写权限，对<code>o</code>设置可读权限，则输入<code>chmod 664 &lt;file&gt;</code>即可。想对所有用户设置最高权限，输入<code>chmod 777 &lt;file&gt;</code>即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>修改文件属主的命令为<code>chown</code>，修改文件属组的命令为<code>chgrp</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://www.cnblogs.com/peida/archive/2012/11/29/2794010.html" target="_blank" rel="noopener">http://www.cnblogs.com/peida/archive/2012/11/29/2794010.html</a><br><a href="https://blog.csdn.net/qq_36221862/article/details/56012469" target="_blank" rel="noopener">https://blog.csdn.net/qq_36221862/article/details/56012469</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>monitorix--服务器监控程序安装及配置</title>
      <link href="/2018/12/monitorix-glances.html"/>
      <url>/2018/12/monitorix-glances.html</url>
      
        <content type="html"><![CDATA[<p>monitorix是一个轻量的Linux监控程序，可以实现远程监控，而且有非常丰富的图形。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以CentOS为例，Ubuntu大同小异。<br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install epel-release</span><br><span class="line">sudo yum -y install glib2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖包</span></span><br><span class="line">sudo yum -y install rrdtool rrdtool-perl perl-libwww-perl perl-MailTools perl-MIME-Lite perl-CGI perl-DBI perl-XML-Simple perl-Config-General perl-HTTP-Server-Simple perl-IO-Socket-SSL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装monitorix</span></span><br><span class="line">sudo yum -y install monitorix</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动monitorix</span></span><br><span class="line">sudo systemctl enable monitorix</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动monitorix</span></span><br><span class="line">sudo systemctl start monitorix</span><br></pre></td></tr></table></figure></p><p>直接在浏览器输入<code>http://IP:8080/monitorix</code>即可访问界面。</p><h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><p>有些服务器设置了防火墙，则需要在防火墙允许8080端口（monitorix默认端口）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>monitorix的默认配置文件为<code>/etc/monitorix/monitorix.conf</code>，具有很丰富的功能，如登录验证、自定义显示等。所有的配置可以在官方文档看到很详细的说明<a href="https://www.monitorix.org/documentation.html" target="_blank" rel="noopener">https://www.monitorix.org/documentation.html</a>。</p><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><p>还是很漂亮的～<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy6d8eteqwj30z10u04af.jpg" alt=""></p><h2 id="记一次大大大大大坑"><a href="#记一次大大大大大坑" class="headerlink" title="记一次大大大大大坑"></a>记一次大大大大大坑</h2><p>丧心病狂！丧心病狂啊！！这个坑找了一个多小时……<br>执行<code>sudo systemctl start monitorix</code>不报任何错，检查了防火墙、依赖包各种都觉得没问题。最终，去挖了日志文件<code>/var/log/monitorix</code>，发现里面报了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: unable to load module &apos;system&apos;. Can&apos;t load &apos;/usr/lib64/perl5/vendor_perl/auto/RRDs/RRDs.so&apos; for module RRDs: /lib64/libpango-1.0.so.0: undefined symbol: g_log_structured_standard at /usr/lib64/perl5/DynaLoader.pm line 190.</span><br></pre></td></tr></table></figure></p><p>重要的一句：<code>undefined symbol: g_log_structured_standard</code><br>Google了大约一年吧……终于在<a href="https://bugs.archlinux.org/task/57869" target="_blank" rel="noopener">https://bugs.archlinux.org/task/57869</a>找到了问题所在……答者写到：</p><blockquote><p>What version of glib2?</p></blockquote><p>遂默默地去安装了glib2……再次开启monitorix服务，访问浏览器地址，进去了哈哈哈哈哈</p><h2 id="glances—一个比top更漂亮的监控命令"><a href="#glances—一个比top更漂亮的监控命令" class="headerlink" title="glances—一个比top更漂亮的监控命令"></a>glances—一个比top更漂亮的监控命令</h2><blockquote><p>Glances 是一个跨平台的、基于命令行的系统监控工具</p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install glances</span><br></pre></td></tr></table></figure><p>如果是anaconda版的Python，最好新建一个环境去安装。否则还需要制作软链接。</p><h3 id="界面-1"><a href="#界面-1" class="headerlink" title="界面"></a>界面</h3><p>glances界面：</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy6dau5escj31c00u0h6d.jpg" alt="glances"></center><br>top界面：</p><p><center><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy6dhrxfn1j31hc0u045c.jpg" alt="top"></center><br>glances更直观更漂亮。</p><h3 id="远程监控"><a href="#远程监控" class="headerlink" title="远程监控"></a>远程监控</h3><p>glances另一个好用的功能为可以远程监控。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install bottle</span><br><span class="line">glances -w</span><br></pre></td></tr></table></figure></p><p>使用浏览器访问<code>http://IP:61208/</code>即可：</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy6ebhv2eoj31ir0u01a3.jpg" alt="glances远程监控"></center><br>要想保持24h运行，要么使用<code>nohup</code>，<code>screen</code>或<code>tmux</code>等命令使<code>glances -w</code>运行不退出，要么将其配置为系统服务，见<a href="https://www.jianshu.com/p/799e8ccbe15f" target="_blank" rel="noopener">https://www.jianshu.com/p/799e8ccbe15f</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.jianshu.com/p/565386e01759" target="_blank" rel="noopener">https://www.jianshu.com/p/565386e01759</a><br><a href="https://bugs.archlinux.org/task/57869" target="_blank" rel="noopener">https://bugs.archlinux.org/task/57869</a><br><a href="https://github.com/nicolargo/glances" target="_blank" rel="noopener">https://github.com/nicolargo/glances</a><br><a href="https://www.jianshu.com/p/799e8ccbe15f" target="_blank" rel="noopener">https://www.jianshu.com/p/799e8ccbe15f</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Anaconda快速使用教程</title>
      <link href="/2018/12/anaconda.html"/>
      <url>/2018/12/anaconda.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Anaconda 是一种Python语言的免费增值开源发行版，用于进行大规模数据处理、预测分析，和科学计算，致力于简化包的管理和部署。Anaconda使用软件包管理系统Conda进行包管理。—<a href="https://zh.wikipedia.org/wiki/Anaconda_(Python%E5%8F%91%E8%A1%8C%E7%89%88" target="_blank" rel="noopener">维基百科</a>)<br>The Most Popular Python Data Science Platform —<a href="https://www.anaconda.com" target="_blank" rel="noopener">https://www.anaconda.com</a></p></blockquote><p>Anaconda具有非常多的优点：开源、全平台支持、优秀的包管理器<code>conda</code>、<strong>简单的环境管理器</strong>、对Python的友好支持……作为日常使用Python和Linux服务器开发的同学简直没有理由不用它啊！<br><a id="more"></a></p><h2 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h2><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>macOS既有图形化界面版本，又有命令行版本<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="noopener">https://www.anaconda.com/download/#macos</a>。<br>对于命令行版本，下载完成后，在对应路径下<code>bash Anaconda3-5.3.1-MacOSX-x86_64.sh</code>安装。安装过程需输入<code>yes</code>同意许可、安装路径、<strong>添加环境变量</strong>。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><blockquote><p>以CentOS为例</p></blockquote><p>执行以下命令即可（<code>wget</code>的链接可能会更新）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh</span><br><span class="line">bash Anaconda3-5.3.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></p><p>安装过程中，同样需要输入<code>yes</code>同意许可、安装路径、<strong>添加环境变量</strong>。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows只有图形化，直接到<a href="https://www.anaconda.com/download/#windows" target="_blank" rel="noopener">https://www.anaconda.com/download/#windows</a>下载安装即可。最重要的配置环境变量，网上教程实在太多了，就不赘述了。</p><h3 id="检查安装"><a href="#检查安装" class="headerlink" title="检查安装"></a>检查安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info</span><br></pre></td></tr></table></figure><p>若能正常输出版本信息等即为安装成功。</p><h2 id="使用conda管理环境和包"><a href="#使用conda管理环境和包" class="headerlink" title="使用conda管理环境和包"></a>使用<code>conda</code>管理环境和包</h2><ul><li><code>conda -h</code>：查看帮助；</li><li><code>conda info -e</code>：查看已有环境；</li><li><code>conda create -n &lt;env_name&gt; &lt;package_names&gt;</code>：创建新环境，并为新环境安装指定的包，可安装指定包的指定版本（可缺省）。例如:<code>conda create -n py3.5 python=3.5</code>；</li><li><code>source activate &lt;env_name&gt;</code>：切换到指定环境。Windows不用加<code>source</code>。或<code>conda activate &lt;env_name&gt;</code>；</li><li><code>source deactivate</code>：退出环境至base。Windows不用加<code>source</code>。或<code>conda deactivate</code>；</li><li><code>conda remove -n &lt;env_name&gt; --all</code>：删除指定环境；</li><li><code>conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt;</code>：复制环境；</li><li><code>conda list</code>：显示当前环境已安装的包；</li><li><code>conda search &lt;package_names&gt;</code>：搜索指定的包。也可使用通配符<code>*</code>模糊查找；</li><li><code>conda install &lt;package_names&gt;</code>：在当前环境安装指定的包；</li><li><code>conda remove &lt;package_names&gt;</code>：卸载当前环境的指定包；</li><li><code>conda update &lt;package_names&gt;</code>：更新当前环境的指定包；</li><li><code>conda update --all</code>：更新当前环境的所有包。</li></ul><blockquote><p>查看命令的帮助只需后加<code>-h</code>即可。例如，<code>conda create -h</code></p></blockquote><h2 id="安装conda中搜索不到的包"><a href="#安装conda中搜索不到的包" class="headerlink" title="安装conda中搜索不到的包"></a>安装<code>conda</code>中搜索不到的包</h2><p>有一部分Python的包在<code>conda</code>中是搜索不到的，这时通过两种方式来安装。</p><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a><code>pip</code>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &lt;package_names&gt;</span><br></pre></td></tr></table></figure><p><code>pip</code>是Python的包管理器，优点是方便，缺点是需要自己安装依赖。</p><h3 id="通过官网搜索安装"><a href="#通过官网搜索安装" class="headerlink" title="通过官网搜索安装"></a>通过官网搜索安装</h3><p>一般通过<code>conda</code>搜索不到指定的包，会出现下图的界面。</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy49apcn6kj31nj0u0at8.jpg" alt="conda搜索不到包" width="80%"></center><br>已经说得很清楚了，在<a href="https://anaconda.org" target="_blank" rel="noopener">https://anaconda.org</a>搜索即可</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy49d17bmhj31ii0n8tc5.jpg" alt="官网搜索包" width="80%"></center><br>一般选择第一个即可</p><p><center><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy49e3i4b8j312s0u0tg5.jpg" width="80%"></center><br>使用图示的命令安装即可。</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy49krf9xdj31dw0u0e28.jpg" alt="安装指定channel的包" width="80%"></center><br>注：<code>conda install</code>的<code>-c</code>参数表示指定对应的<code>channel</code>安装。</p><h3 id="添加清华的镜像"><a href="#添加清华的镜像" class="headerlink" title="添加清华的镜像"></a>添加清华的镜像</h3><p>TUNA提供了Anaconda仓库的镜像，可以加速访问速度。而且维护了一些anaconda三方源。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 添加Anaconda仓库的镜像</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"><span class="meta">#</span> 添加Conda Forge源</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure></p><p>添加了以上的源之后，大部分包都能搜索得到了。还有搜索不到的可按照前两种方式再安装。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://zhuanlan.zhihu.com/p/32925500" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32925500</a><br><a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/anaconda/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh连接服务器超时解决方案</title>
      <link href="/2018/12/ssh-timeout.html"/>
      <url>/2018/12/ssh-timeout.html</url>
      
        <content type="html"><![CDATA[<p>经常需要连接到Linux服务器，发现过一段时间不输入命令，服务器的ssh连接就会断开，又需要重新ssh登录。<br><a id="more"></a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在Linux服务器端配置<code>/etc/ssh/sshd_config</code>文件，修改其中两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval 60</span><br><span class="line">ClientAliveCountMax 60</span><br></pre></td></tr></table></figure></p><p>其中，<code>ClientAliveInterval</code>表示服务器每隔多久向客户端发送一个“空包”，以保持连接，单位为秒，此处为60秒；<code>ClientAliveCountMax</code>表示如果发现客户端没有响应，则判断一次超时，这个参数为允许超时的次数，此处为60次。相当于1小时无通信后断开ssh连接。<br>之后重启ssh服务：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ssh</span><br></pre></td></tr></table></figure></p><p>再重新ssh连接即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.awaimai.com/2523.html" target="_blank" rel="noopener">https://www.awaimai.com/2523.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强大的tmux</title>
      <link href="/2018/12/tmux.html"/>
      <url>/2018/12/tmux.html</url>
      
        <content type="html"><![CDATA[<p>之前在服务器跑代码的时候用到了<a href="https://suixinblog.cn/2018/11/screen.html"><code>screen</code>会话管理命令</a>，可以新建不同的session来不间断运行shell。而<code>tmux</code>更为强大，不仅提供了会话的管理，还支持同一窗口下分出不同的窗格。<br>总的来说，<code>tmux</code>的结构分为：</p><ul><li>session<ul><li>window<ul><li>pane</li></ul></li></ul></li></ul><a id="more"></a><h2 id="命令行安装"><a href="#命令行安装" class="headerlink" title="命令行安装"></a>命令行安装</h2><p><code>macos</code>使用<code>brew install tmux</code>进行安装；<br><code>CentOS</code>使用<code>yum install tmux</code>进行安装时发现版本为1.8较低，所以通过源码编译的方式进行安装：</p><ol><li><p>安装依赖：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ncurses-devel</span><br><span class="line">yum -y install libevent-devel</span><br></pre></td></tr></table></figure></li><li><p>安装<code>tmux</code></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tmux/tmux.git</span><br><span class="line">cd tmux</span><br><span class="line">sh autogen.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若提示找不到aclocal命令，则安装yum install -y automake</span></span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若提示没有C编译器，则安装yum install -y gcc</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>检查版本</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmux -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能提示无tmux命令，制作软连接即可</span></span><br><span class="line">ln -s /usr/local/bin/tmux /usr/bin/tmux</span><br></pre></td></tr></table></figure></li></ol><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p><code>tmux new -s &lt;name&gt;</code>：<strong>新建</strong>名为<code>name</code>的会话（无<code>-s</code>参数则默认以数字命名）；<br><code>tmux at -t &lt;name&gt;</code>：<strong>恢复（attach）</strong>名为<code>name</code>的会话（无<code>-t</code>参数则默认恢复上一次的会话（<code>at</code>可简写为<code>a</code>）；<br><code>tmux ls</code>：<strong>列出</strong>所有会话；<br><code>tmux kill-session -t &lt;name&gt;</code>：<strong>关闭</strong>名为<code>name</code>的会话；<br><code>tmux kill-server</code>：关闭所有会话。</p><h2 id="快捷键（在tmux-session中）"><a href="#快捷键（在tmux-session中）" class="headerlink" title="快捷键（在tmux session中）"></a>快捷键（在tmux session中）</h2><p>这里所有的快捷键都是以<code>Ctrl+B</code>开头的（Mac也是<code>⌃+B</code>而不是<code>⌘+B</code>）。以下所有命令均在按下前缀<code>Ctrl+B</code>后再按下生效。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><code>D</code>：<strong>分离（detach）</strong>当前会话（会话仍在后台运行）；<br><code>S</code>：列出所有会话，此时可通过方向键和回车键切换；<br><code>$</code>：重命名当前会话；<br><code>:new -s &lt;name&gt;</code>：创建并进入名为<code>name</code>的会话（不存在父子级关系）。</p><h3 id="窗口（标签页）"><a href="#窗口（标签页）" class="headerlink" title="窗口（标签页）"></a>窗口（标签页）</h3><p><strong>窗口</strong>在tmux中相当于同一个session下的子窗口。<br>想到的使用场景为：在一个多人使用的服务器下，你只需新建自己名字的session<code>tmux new -s suixin</code>，想要再新建会话时，不去<code>tmux new -s suixin2</code>，而是选择在已有的<code>suixin</code>session下新建窗口，避免了多用户用<code>tmux</code>开启巨多session的困扰。（说的有点绕……）<br><code>c</code>：新建窗口；<br><code>w</code>：列出所有窗口，此时可通过方向键和回车键切换；<br><code>n</code>：切换到后一个窗口（使用后面的主题后失效）；<br><code>p</code>：切换到前一个窗口（使用后面的主题后失效）；<br><code>,</code>：重命名当前窗口（不知是否可以在创建时就命名）；<br><code>&amp;</code>：关闭当前窗口。</p><h3 id="窗格（分割窗口）"><a href="#窗格（分割窗口）" class="headerlink" title="窗格（分割窗口）"></a>窗格（分割窗口）</h3><p><strong>窗格</strong>为<code>tmux</code>优于<code>screen</code>的一个强大的功能，可以实现在同一个窗口下分割窗口为多个窗格运行不同的命令，一览无余。棒棒棒！！<br><code>%</code>：垂直分割；<br><code>:</code>：水平分割；<br><code>x</code>：关闭窗格（也可以直接在命令行输入<code>exit</code>）；<br><code>o</code>：交换窗格（将输入切换到下一个窗格）；<br><code>q</code>：显示窗格的编号（和尺寸），此时可通过按下数字切换（使用后面的主题后数字切换失效）；<br><code>{</code>：与上一个窗格交换位置；<br><code>}</code>：与下一个窗格交换位置。</p><h2 id="一个漂亮的tmux配置"><a href="#一个漂亮的tmux配置" class="headerlink" title="一个漂亮的tmux配置"></a>一个漂亮的tmux配置</h2><p>有人配置了一个比较全的tmux，见<a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux</a> 。<br><strong>新特性</strong>：</p><ul><li>鼠标（开启键为<code>Ctrl+A+M</code>）。可切换windows、panes，鼠标滚动，复制等；</li><li>快捷键前缀改为<code>Ctrl+A</code>并兼容<code>Ctrl+B</code>；</li><li>更改了部分快捷键，使之更方便，见<a href="https://github.com/gpakosz/.tmux#bindings" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux#bindings</a> ；</li><li>美化底栏；</li><li>窗口编号从1开始；</li><li>当前窗口用蓝底显示，当前pane用蓝框显示；</li><li>漂亮的界面。</li></ul><p>拉取文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s -f .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local ./</span><br></pre></td></tr></table></figure></p><p>我修改了<code>~/.tmux.conf.local</code>文件中的左右底栏配置，然后<code>source</code>该文件（好像Linux服务器不能显示电池信息）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmux_conf_theme_status_left=&apos; ❐ #S &apos;</span><br><span class="line">tmux_conf_theme_status_right=&apos;#&#123;prefix&#125;#&#123;pairing&#125;#&#123;synchronized&#125; #&#123;?battery_status, #&#123;battery_status&#125;,&#125;#&#123;?battery_bar, #&#123;battery_bar&#125;,&#125;#&#123;?battery_percentage, #&#123;battery_percentage&#125;,&#125; , %R , %d %b | #&#123;loadavg&#125; | #&#123;username&#125;#&#123;root&#125; | #&#123;hostname&#125; &apos;</span><br></pre></td></tr></table></figure></p><p>我比较常用的窗格设置，左边主界面，右上角可以实时<code>cd</code>到某些文件夹查看，右下角为<code>top</code>：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxylrik0mbj31c00u07wh.jpg" alt=""></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>Ctrl+B+T</code>：显示时间，按任意键返回。<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxyltju6r7j31c00u0u0e.jpg" alt=""></p><p>查找窗口、调整窗口排序、调整窗格尺寸、同步窗格、文本复制模式等功能在参考中可以找到。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7" target="_blank" rel="noopener">https://gist.github.com/ryerh/14b7c24dfd623ef8edc7</a><br><a href="https://github.com/gpakosz/.tmux" target="_blank" rel="noopener">https://github.com/gpakosz/.tmux</a><br><a href="https://harttle.land/2015/11/06/tmux-startup.html" target="_blank" rel="noopener">https://harttle.land/2015/11/06/tmux-startup.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux多重视窗管理命令screen</title>
      <link href="/2018/11/screen.html"/>
      <url>/2018/11/screen.html</url>
      
        <content type="html"><![CDATA[<p>在日常的编码中肯定需要登录到远程Linux服务器，经常需要在上面运行一些需要很长时间才能完成的任务，如：传输文件、跑爬虫代码等，需要保证退出服务器的连接，该任务也不会终止掉。使用<code>nohup</code>命令已经可以完成一些较为简单的任务（<a href="https://suixinblog.cn/2018/11/nohup.html">nohup：在Linux服务器后台跑程序</a>），但真正的多会话管理还是要用到<code>screen</code>命令。<br>一般的Linux系统都自带<code>screen</code>命令，所以无需手动安装。<br><a id="more"></a></p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li><code>-S</code>：后加作业名称新建一个screen作业；</li><li><code>-ls</code>或<code>-list</code>：列出目前的所有screen作业；</li><li><code>-d</code>：后加作业名称远程使该作业离线；</li><li><code>-r</code>：后加作业名称恢复该离线的作业；</li><li><code>-wipe</code>：删除已经无法使用的作业。</li></ul><h2 id="快捷键（在screen-session中）"><a href="#快捷键（在screen-session中）" class="headerlink" title="快捷键（在screen session中）"></a>快捷键（在screen session中）</h2><p>进入一个screen session后，可能你开始跑一些程序，这时不能在命令行输入任何东西，就需要使用快捷键来操作。这里所有的快捷键都是以<code>Ctrl+A</code>开头的（Mac也是<code>⌃+A</code>而不是<code>⌘+A</code>）。</p><ul><li><code>Ctrl+A+D</code>：detach当前session，会将当前的session任务放到后台执行，回到还没进入当前session的状态，即使断开远程连接session也不会中断（<strong>最常用</strong>）；</li><li><code>Ctrl+A+T</code>：在底线显示当前时间以及登入时间；</li><li><code>Ctrl+A+K</code>：强行关闭当前的window；</li><li><code>Ctrl+A+W</code>：显示所有window列表；</li><li><code>Ctrl+A+X</code>：锁定当前window，需要用用户密码解锁。</li></ul><h2 id="在session中启用鼠标滚动"><a href="#在session中启用鼠标滚动" class="headerlink" title="在session中启用鼠标滚动"></a>在session中启用鼠标滚动</h2><p>screen默认设置中在session中不能使用鼠标滚屏。通过在<code>/etc/screenrc</code>文件中加入以下内容启动鼠标滚动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">termcapinfo xterm* ti@:te@</span><br></pre></td></tr></table></figure></p><h2 id="经典使用方式"><a href="#经典使用方式" class="headerlink" title="经典使用方式"></a>经典使用方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 新建suixinPython作业</span><br><span class="line">screen -S suixinPython</span><br><span class="line"><span class="meta">#</span> 在新作业中运行长时间的代码</span><br><span class="line">python test.py</span><br><span class="line"><span class="meta">#</span> 使用快捷键detach当前session</span><br><span class="line">⌃+A+D</span><br><span class="line"><span class="meta">#</span> 退出ssh连接</span><br><span class="line">exit</span><br><span class="line"><span class="meta">#</span> 重新链接服务器</span><br><span class="line">ssh root@……</span><br><span class="line"><span class="meta">#</span> 恢复suixinPython会话</span><br><span class="line">screen -r suixinPython</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html" target="_blank" rel="noopener">https://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux压缩和解压命令：tar，gzip，zip（unzip），rar</title>
      <link href="/2018/11/tar-gzip-zip-rar.html"/>
      <url>/2018/11/tar-gzip-zip-rar.html</url>
      
        <content type="html"><![CDATA[<p>很多大型文件或者数据从服务器上传或者下载的时候都需要打包和压缩解压，这时候知道压缩和解压的各种命令是很有必要的。<br>常见的压缩文件后缀名有<code>.tar.gz</code>，<code>.gz</code>，<code>.zip</code>和<code>.rar</code>，下面来看看在Linux上它们分别的解压和压缩命令。<br><a id="more"></a></p><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>Linux压缩文件中最常见的后缀名即为<code>.gz</code>，<code>gzip</code>是用来压缩和解压<code>.gz</code>文件的命令。</p><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-d</code>或<code>--decompress</code>或<code>--uncompress</code>：解压文件；</li><li><code>-r</code>或<code>--recursive</code>：递归压缩指定文件夹下的文件（该文件夹下的所有文件被压缩成单独的<code>.gz</code>文件）；</li><li><code>-v</code>或<code>--verbose</code>：显示指令执行过程。</li></ul><p><strong>注</strong>：<code>gzip</code>命令只能压缩单个文件，而不能把一个文件夹压缩成一个文件（与打包命令的区别）。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>压缩当前目录下所有文件，并显示进度：</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxei1viqinj31020i2alj.jpg" width="80%" alt="gzip"></center></p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><code>tar</code>本身是一个打包命令，用来打包或者解包后缀名为<code>.tar</code>。配合参数可同时实现打包和压缩。</p><h3 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>-c</code>或<code>--create</code>：建立新的备份文件；</li><li><code>-x</code>或<code>--extract</code>或<code>--get</code>：从备份文件中还原文件；</li><li><code>-v</code>：显示指令执行过程；</li><li><code>-f</code>或<code>--file</code>：指定备份文件；</li><li><code>-C</code>：指定目的目录；</li><li><code>-z</code>：通过<code>gzip</code>指令处理备份文件；</li><li><code>-j</code>：通过<code>bzip2</code>指令处理备份文件。</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>最常用的是将<code>tar</code>命令与<code>gzip</code>命令组合起来，直接对文件夹先打包后压缩：</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxetbja0swj31e60n81a0.jpg" width="80%" alt="tar打包压缩"></center><br>解压解包：</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxetew4avbj31aw0n67kt.jpg" width="80%" alt="tar解压解包"></center></p><h2 id="zip和unzip"><a href="#zip和unzip" class="headerlink" title="zip和unzip"></a>zip和unzip</h2><p><code>zip</code>命令和<code>unzip</code>命令用在在Linux上处理<code>.zip</code>的压缩文件。</p><h3 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>zip</code><ul><li><code>-v</code>：显示指令执行过程；</li><li><code>-m</code>：不保留原文件；</li><li><code>-r</code>：递归处理。</li></ul></li><li><code>unzip</code><ul><li><code>-v</code>：显示指令执行过程；</li><li><code>-d</code>：解压到指定目录。</li></ul></li></ul><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>将两个文件压缩为<code>new.zip</code>且保留原文件：</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxeu5yhebdj31aa0j8h0b.jpg" width="80%" alt="zip"></center><br>将<code>new.zip</code>解压到上级目录：</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxeu5y0n96j313i0og7kb.jpg" width="80%" alt="unzip"></center></p><h2 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h2><p><code>.rar</code>是Windows上比较常见的压缩文件格式，在Linux上使用<code>rar</code>命令来操作。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Linux中默认不带<code>rar</code>工具，需要自行安装，在<a href="https://www.rarlab.com/download.htm" target="_blank" rel="noopener">RARLAB</a>找到自己系统位数对应链接下载直接编译即可，如<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.rarlab.com/rar/rarlinux-x64-5.6.1.tar.gz</span><br><span class="line">tar -zxvf rarlinux-x64-5.6.1.tar.gz</span><br><span class="line">cd rar</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><h3 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li><code>a</code>：压缩文件；</li><li><code>x</code>：解压文件；</li><li><code>-p</code>：设置密码。密码紧随其后，如<code>-p123</code>。</li></ul><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>将两个文件压缩为<code>new.rar</code>，设置密码为123（默认保留原文件）：</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxev056zfxj31cy0tikao.jpg" width="80%" alt="rar压缩"></center><br>将<code>new.rar</code>解压（默认保留原文件）：</p><p><center><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxev10vxyvj316u0u04h9.jpg" width="80%" alt="rar解压"></center></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html" target="_blank" rel="noopener">https://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html</a><br><a href="https://blog.csdn.net/zyw_anquan/article/details/8672024" target="_blank" rel="noopener">https://blog.csdn.net/zyw_anquan/article/details/8672024</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下载命令wget</title>
      <link href="/2018/11/wget.html"/>
      <url>/2018/11/wget.html</url>
      
        <content type="html"><![CDATA[<p><code>wget</code>是Linux下下载文件的最常用命令。<code>wget</code>支持<code>HTTP</code>，<code>HTTPS</code>和<code>FTP</code>协议，支持自动下载，即可以在用户退出系统后在后台执行，直到下载结束。<br><strong>用法</strong>：<code>wget [参数] [URL]</code><br><a id="more"></a></p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul><li><code>-o</code>：将日志信息写入FILE；</li><li><code>-b</code>：启动后转入后台；</li><li><code>-O</code>：将文档写入FILE（重命名）；</li><li><code>-q</code>：安静模式（无信息输出）；</li><li><code>-N</code>：只获取比本地文件新的文件；</li><li><code>--no-check-certificate</code>：不要验证HTTPS服务器的证书；</li><li><code>-r</code>：指定递归下载；</li><li><code>-c</code>：断点续传下载文件。</li></ul><p><strong>最常用</strong>：<code>wget -O newname URL</code>，如：</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxaanor5epj31da0i0k5i.jpg" width="80%" alt="wget gif"><center></center></center></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSR搭建教程</title>
      <link href="/2018/11/ssr.html"/>
      <url>/2018/11/ssr.html</url>
      
        <content type="html"><![CDATA[<p>随着服务器的入门门槛越来越低，使用自己的服务器搭建一个梯·子以及放一些自己的网站（博客）也越来越简单。下面主要总结一下使用服务器搭建梯·子的方法。<br><a id="more"></a></p><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>现在服务器的价格越来越便宜了，像阿里云/腾讯云/华为云都推出了自己的学生优惠计划，见下：<br><a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">阿里云翼计划</a>：¥9.5/月</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx9vc39j5mj31jp0u0qc8.jpg" width="80%" alt="阿里云翼计划"></center><br><a href="https://cloud.tencent.com/act/campus" target="_blank" rel="noopener">腾讯云+校园</a>：¥10/月</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx9vey23itj31v20q4tey.jpg" width="80%" alt="腾讯云+校园"></center><br><a href="https://developer.huaweicloud.com/campus" target="_blank" rel="noopener">华为云创校园计划</a>：¥9/月</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx9vf1gzyqj31us0sm48s.jpg" width="80%" alt="华为云创校园计划"></center><br><strong>但是！但是！</strong>这些厂商的学生机都是放在国内的服务器，均不能搭梯·子……【那你说个*】，还是可以用来放网站和学习服务器的嘛^-^<br>国内厂商也推出了放在国外的服务器，但价格都比较贵。所以可以到一些国外的服务器提供商购买，如<a href="https://www.vultr.com/" target="_blank" rel="noopener">Vultr</a>，<a href="https://bandwagonhost.com/" target="_blank" rel="noopener">Bandwagonhost</a>和<a href="https://www.digitalocean.com/" target="_blank" rel="noopener">DigitalOcean</a>。</p><h3 id="DigitalOcean"><a href="#DigitalOcean" class="headerlink" title="DigitalOcean"></a>DigitalOcean</h3><p>如果你是学生，这里强势推荐一下DigitalOcean，你可以在GitHub教育认证链接<a href="https://education.github.com/pack/join" target="_blank" rel="noopener">https://education.github.com/pack/join</a> 认证为学生用户，就可以直接得到DO的$50优惠券代码，如果按照DO的最低配置VPS算，够使用10个月了。而且，使用这个<a href="https://m.do.co/c/4a7d2507a4ad" target="_blank" rel="noopener">推荐注册链接</a>你还可以得到额外的100刀优惠（有效期60天）。注册时唯一麻烦的地方是需要绑定PayPal账户并支付5刀验证支付能力，当然这5刀也会进入DO的账户。</p><h2 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h2><p>如果你是Mac OS/Linux，则可以直接通过<code>ssh</code>命令来连接服务器；如果是Windows，则需要通过XShell/<a href="http://www.hostbuf.com/t/988.html" target="_blank" rel="noopener">FinalShell</a>等软件来连接。<br>登录服务器后，使用<a href="https://github.com/ToyoDAdoubi" target="_blank" rel="noopener">ToyoDAdoubi</a>大神写的一件部署脚本直接部署，以CentOS系统为例，命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh</span><br><span class="line">chmod +x ssr.sh</span><br><span class="line">bash ssr.sh</span><br></pre></td></tr></table></figure></p><p>安装过程，除了端口/密码需自定义外，混淆/协议等使用默认即可，还有确认安装文件的，输入<code>y</code>确认即可。</p><h2 id="BBR加速"><a href="#BBR加速" class="headerlink" title="BBR加速"></a>BBR加速</h2><p>使用<a href="https://github.com/chiakge" target="_blank" rel="noopener">Chikage</a>大神做的魔改版BBR加速一件部署脚本，代码如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh"</span><br><span class="line">chmod +x tcp.sh</span><br><span class="line">bash tcp.sh</span><br></pre></td></tr></table></figure></p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fx9wk94521j308d08tt9e.jpg" width="40%" alt="BBR一键加速脚本"></center><br>接下来按照流程安装就好了，使用BBR魔改版加速速度更快，但好像访问谷歌学术会挂，使用原BBR加速则不会……</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx9wm29ukfj31sw0ea40n.jpg" width="80%" alt="BBR魔改版访问谷歌学术"></center></p><h2 id="S·S·R客户端下载"><a href="#S·S·R客户端下载" class="headerlink" title="S·S·R客户端下载"></a>S·S·R客户端下载</h2><p>Windows客户端：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">下载地址</a><br>Mac客户端：<a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases" target="_blank" rel="noopener">下载地址</a><br>安卓客户端：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases/download/3.4.0.8/shadowsocksr-release.apk" target="_blank" rel="noopener">下载地址</a><br>iPhone客户端可选的有Potatso Lite、Potatso、Shadowrocket等，但国内App Store都已经下架，需要登录海外的 ID或者使用一些代理软件下载。<br>安装好之后在软件中输入部署服务器时设置的信息即可成功登录。</p><p>Google欢迎你～</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx9wubfsgwj316a0u0dob.jpg" width="80%" alt="Suixin's Blog"></center></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B</a><br><a href="https://www.94ish.me/1635.html" target="_blank" rel="noopener">https://www.94ish.me/1635.html</a><br><a href="https://www.weiweiblog.cn/cloud/" target="_blank" rel="noopener">https://www.weiweiblog.cn/cloud/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nohup：在Linux服务器后台跑程序</title>
      <link href="/2018/11/nohup.html"/>
      <url>/2018/11/nohup.html</url>
      
        <content type="html"><![CDATA[<p>一些时间长的命令经常需要在后台运行，但苦于通常我们都是通过PC去连接服务器，一直保持<code>ssh</code>连接是不太现实的，这时就需要一些命令使得断开<code>ssh</code>连接后服务器依旧在运行命令。<br><a id="more"></a></p><h2 id="命令后面加-amp-在后台运行"><a href="#命令后面加-amp-在后台运行" class="headerlink" title="命令后面加&amp;在后台运行"></a>命令后面加<code>&amp;</code>在后台运行</h2><p>用法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><p>其中：</p><blockquote><p><code>&gt;</code>表示将标准输出（STDOUT）重定向到<code>test.log</code>文件；<br><code>2&gt;&amp;1</code>表示将标准错误（STDERR）重定向到标准输出。<code>1</code>是标准输出的文件描述符，<code>2</code>是标准错误的文件描述符；<br><code>&amp;</code>表示将程序放到后台运行。</p></blockquote><p>这样，我们已经将命令放到了后台执行。但是，只要我们断开<code>ssh</code>连接，进程将会被终止，是因为我们运行命令的<code>session</code>属于<code>ssh</code>的子进程。</p><h2 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a><code>nohup</code>命令</h2><p>使用<code>nohup</code>即可实现断开<code>ssh</code>连接命令也不会被终止。<code>nohup</code>: no hang up.<br>用法：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python -u test.py &gt; test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p><p>其中，Python的<code>-u</code>参数用来禁用缓冲区，将输出直接写入文件。<br>运行之后可通过<code>jobs</code>查看正在运行的任务。<br>重新登录之后使用<a href="https://suixinblog.cn/2018/10/ps-grep-tail.html#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8">ps和grep命令</a>可查看后台进程，如<code>ps aux|grep python</code>可查看所有关于<code>python</code>的进程。<br><strong>注</strong>：以上方法适用于大部分命令，将下载和上传的任务放到后台也是很方便的～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://iyuluo.com/2017/11/01/Linux-%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8CPython%E8%84%9A%E6%9C%AC/" target="_blank" rel="noopener">http://iyuluo.com/2017/11/01/Linux-%E4%B8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8CPython%E8%84%9A%E6%9C%AC/</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux三个命令：ps，grep，tail</title>
      <link href="/2018/10/ps-grep-tail.html"/>
      <url>/2018/10/ps-grep-tail.html</url>
      
        <content type="html"><![CDATA[<p>这几天在服务器上跑Python的几个程序，因为运行时间较长，所以涉及到后台运行的问题，顺便也深入了解了一下Linux的几个命令。<br><a id="more"></a></p><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>ps</code>命令用来显示当前的进程。是Process Status的缩写。如果需要动态的显示进程，可以使用<code>top</code>命令。</p><h3 id="ps常用参数"><a href="#ps常用参数" class="headerlink" title="ps常用参数"></a><code>ps</code>常用参数</h3><ul><li><code>-A</code>，<code>-e</code>：列出所有的进程；</li><li><code>aux</code>：列出所有使用者的详细进程（<strong>最常用</strong>）；</li><li><code>u</code>：指定用户的进程；</li><li><code>r</code>：列出正在运行的程序；</li><li><code>T</code>：当前终端的所有进程。</li></ul><h3 id="输出列的含义"><a href="#输出列的含义" class="headerlink" title="输出列的含义"></a>输出列的含义</h3><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwroxuknxrj319c07on2g.jpg" width="80%"></center><br>上图中的各列分别代表：</p><ul><li>USER：进程拥有者；</li><li>PID：进程的ID；</li><li>%CPU：CPU占用率；</li><li>%MEM：内存占用率；</li><li>VSE：该进程使用掉的虚拟内存量 (Kbytes)；</li><li>RSS：该进程占用的固定的内存量 (Kbytes)；</li><li>TTY：该进程是在那个终端机上面运作。若与终端机无关，则显示<code>?</code>；<code>tty1-tty6</code>是本机上面的登入者程序；<code>pts/0</code>等等则表示为由网络连接进主机的程序；</li><li>STAT：该程序目前的状态。<ul><li><code>R</code>：正在执行；</li><li><code>S</code>：睡眠状态。在等待某个条件的形成或接受到信号；</li><li><code>D</code>：不可中断。收到信号不唤醒和不可运行，进程必须等待直到有中断发生；</li><li><code>T</code>：终止。进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行；</li><li><code>Z</code>：僵死。进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放；</li><li><code>&lt;</code>：高优先级进程；</li><li><code>N</code>：低优先级进程；</li><li><code>s</code>：进程的领导者（在它之下有子进程）；</li><li><code>l</code>：多进程，克隆线程；</li><li><code>+</code>：位于后台的进程组。</li></ul></li><li>START：进程启动时间和日期；</li><li>TIME：进程使用的总cpu时间；</li><li>COMMAND：正在执行的命令行命令。</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><code>grep</code>命令用于查找文件里符合条件的字符串。<br>使用格式：<code>grep [option] pattern file</code></p><h3 id="grep常用参数"><a href="#grep常用参数" class="headerlink" title="grep常用参数"></a>grep常用参数</h3><ul><li><code>i</code>：忽略大小写；</li><li><code>r</code>：递归的查找（<strong>当查找一个目录而不是文件时必须加上</strong>）；</li><li><code>v</code>：反向查找。显示不包含匹配文本的行；</li><li><code>*py</code>：在<code>file</code>处可直接指定文件后缀。</li></ul><p><strong>注</strong>：<code>pattern</code>可使用正则表达式。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在当前目录的后缀为<code>.py</code>的文件中查找<code>import</code></p><p><center><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwrpxzd3msj311k0eqaj9.jpg" width="80%"></center><br>在目录<code>/code</code>中递归地查找<code>import</code></p><p><center><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwrq0pd5u9j314i0eqk1w.jpg" width="80%"></center><br>在当前目录文件名包含<code>t</code>的文件中查找不包含<code>=</code>的内容</p><p><center><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwrq3utbgvj30zm0g245w.jpg" width="80%"></center></p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>用于查看文件的内容，有一个常用的参数<code>-f</code>常用于查阅正在改变的日志文件。<br>使用格式：<code>tail [parameter] file</code></p><h3 id="tail常用参数"><a href="#tail常用参数" class="headerlink" title="tail常用参数"></a>tail常用参数</h3><ul><li><code>-f</code>：循环读取。对于正在修改的文件比较有用（如日志文件）；</li><li><code>-n</code>：显示文件最后几行；</li><li><code>-s</code>：与<code>-f</code>合用，表示在每次循环间隙几秒。</li></ul><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>最经典的用法：使用<code>Linux</code>的终端中的<strong>管道符号</strong><code>|</code><sup><a href="#fn_1" id="reffn_1">1</a></sup>在进程中查找，如<code>ps aux|grep python</code>；<br>实现按照进程的CPU占用率/内存占用率排序：<code>ps aux --sort -pcpu</code>或<code>ps aux --sort -pmem</code>；<br>只输出少量信息（按<code>enter</code>查看更多）：<code>ps aux --sort -pcpu|less</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.runoob.com/linux" target="_blank" rel="noopener">http://www.runoob.com/linux</a><br><a href="http://www.cnblogs.com/peida" target="_blank" rel="noopener">http://www.cnblogs.com/peida</a><br><a href="https://www.jianshu.com/p/e1abfb1d9e8d" target="_blank" rel="noopener">https://www.jianshu.com/p/e1abfb1d9e8d</a></p><blockquote id="fn_1"><sup>1</sup>. 用法: <code>command1 | command2</code>，它的功能是把第一个命令<code>command 1</code>执行的结果作为<code>command 2</code>的输入传给<code>command 2</code><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性分类模型(四)——贝叶斯观点下的Logistic回归</title>
      <link href="/2018/10/linear-classification4.html"/>
      <url>/2018/10/linear-classification4.html</url>
      
        <content type="html"><![CDATA[<h2 id="拉普拉斯近似"><a href="#拉普拉斯近似" class="headerlink" title="拉普拉斯近似"></a>拉普拉斯近似</h2><p>目标：因为待近似的分布$p(\pmb{z})$不是高斯分布，故寻找一个高斯近似$q(\pmb{z})$，它的中心位于$p(\pmb{z})$的众数的位置。<br>思路：将待近似的分布$p(\pmb{z})$在众数$\pmb{z}_0$做泰勒展开，去掉三阶项以及更高阶。<br><a id="more"></a><br>假设待近似分布为$M$维$p(\pmb{z})=\frac{f(\pmb{z})}{Z}$，在众数$\pmb{z}_0$处展开，有</p><script type="math/tex; mode=display">\ln f(\pmb{z})\simeq \ln f(\pmb{z}_0)-\frac{1}{2}(\pmb{z}-\pmb{z}_0)^\top A(\pmb{z}-\pmb{z}_0)</script><p>其中，$M\times M$的Hessian矩阵$A=-\nabla\nabla\ln f(\pmb{z})|_{\pmb{z}=\pmb{z}_0}$。两边同取指数，有</p><script type="math/tex; mode=display">f(\pmb{z})\simeq f(\pmb{z}_0)\exp\{-\frac{1}{2}(\pmb{z}-\pmb{z}_0)^\top A(\pmb{z}-\pmb{z}_0)\}</script><p>分布$q(\pmb{z})$正比于$f(\pmb{z})$，因此</p><script type="math/tex; mode=display">q(\pmb{z})=\frac{|A|^\frac{1}{2}}{(2\pi )^\frac{M}{2}}\exp\{-\frac{1}{2}(\pmb{z}-\pmb{z}_0)^\top A(\pmb{z}-\pmb{z}_0)\}=\mathscr{N}(\pmb{z}|\pmb{z}_0,A^{-1})</script><p>其中，这个高斯分布well-define的前提为$A$是正定的，即驻点$\pmb{z}_0$必须为一个局部极大值。在实际应用拉普拉斯近似时需计算众数，一般通过数值优化算法得到。<br><strong>缺点：</strong>对于多峰问题会给出较差的结果。<br><strong>优点：</strong>在数据点较多的情况下，会更有用。</p><h2 id="贝叶斯Logistic回归"><a href="#贝叶斯Logistic回归" class="headerlink" title="贝叶斯Logistic回归"></a>贝叶斯Logistic回归</h2><p>Logistic回归不能进行精确的贝叶斯推断的原因：后验分布为先验分布与似然函数的乘积的归一化，而似然函数为一系列sigmoid函数的乘积。</p><h3 id="对后验分布做拉普拉斯近似"><a href="#对后验分布做拉普拉斯近似" class="headerlink" title="对后验分布做拉普拉斯近似"></a>对后验分布做拉普拉斯近似</h3><p>假设参数$\pmb{w}$有高斯先验</p><script type="math/tex; mode=display">p(\pmb{w})=\mathscr{N}(\pmb{w}|\pmb{m}_0,S_0)</script><p>其中，$\pmb{m}_0$和$S_0$为固定的超参数。$\pmb{w}$的后验分布为</p><script type="math/tex; mode=display">p(\pmb{w}|\textbf{t})\propto p(\pmb{w})p(\textbf{t}|\pmb{w})</script><p>化简可得对数后验为</p><script type="math/tex; mode=display">\ln p(\pmb{w}|\textbf{t})=-\frac{1}{2}(\pmb{w}-\pmb{m}_0)^\top S_0^{-1}(\pmb{w}-\pmb{m}_0)+\sum_{n=1}^N\{t_n\ln y_n+(1-t_n)\ln(1-y_n)\}+Constant</script><p>其中，符号与上一篇文章一致。现在，只需极大化后验概率分布，求出MAP解$\pmb{w}_{MAP}$，再根据前面的拉普拉斯近似结果可得后验分布的高斯近似为</p><script type="math/tex; mode=display">q(\pmb{w})=\mathscr{N}(\pmb{w}|\pmb{w}_{MAP},S_N)</script><p>其中，</p><script type="math/tex; mode=display">S_N^{-1}=-\nabla\nabla\ln p(\pmb{w}|\textbf{t})=S_0^{-1}+\sum_{n=1}^Ny_n(1-y_n)\pmb{\phi}_n\pmb{\phi}_n^\top</script><h3 id="预测分布"><a href="#预测分布" class="headerlink" title="预测分布"></a>预测分布</h3><p>给定一个新的特征向量$\phi(\pmb{x})$，类别$C_1$的预测分布可对后验概率$p(\pmb{w}|\textbf{t})$积分得到</p><script type="math/tex; mode=display">p(C_1|\pmb{\phi},\textbf{t})=\int p(C_1|\pmb{\phi},\pmb{w})p(\pmb{w}|\textbf{t})d\pmb{w}\simeq\int \sigma(\pmb{w}^\top \pmb{\phi})q(\pmb{w})d\pmb{w}</script><p>具体求解预测分布过程见参考$\S4.5.2$。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xueshu.baidu.com/s?wd=paperuri%3A%28039d5c0802df10a9c04decf174c5409d%29&amp;filter=sc_long_sign&amp;sc_ks_para=q%3DPattern%20Recognition%20and%20Machine%20Learning%20%28Information%20Science%20and%20Statistics%29&amp;sc_us=9652015233931872413&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8" target="_blank" rel="noopener">“Pattern Recognition and Machine Learning”</a></p>]]></content>
      
      
      <categories>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性分类模型(三)——判别式模型</title>
      <link href="/2018/10/linear-classification3.html"/>
      <url>/2018/10/linear-classification3.html</url>
      
        <content type="html"><![CDATA[<p>判别式方法：直接对条件概率分布$p(C_k|\pmb{x})$进行建模。<br>相比生成式方法有两个优点：需要训练的参数更少，预测表现会提升（尤其当类条件概率密度的假设没有很好的近似真实分布的时候）。</p><h2 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h2><a id="more"></a><p>对于二分类问题，类别$C_1$的后验概率为</p><script type="math/tex; mode=display">p(C_1|\pmb{\phi})=y(\pmb{\phi})=\sigma(\pmb{w}^\top\pmb{\phi})</script><p>可见，对于$M$维特征空间$\pmb{\phi}$，该模型只有$M$个可调节参数，而生成式模型需要调节参数总数为$\frac{M(M+5)}{2}+1$。<br>对于一个数据集$\{\pmb{\phi}_n,t_n\}$，其中，$t_n\in \{0,1\}$且$\pmb{\phi}_n=\phi(\pmb{x}_n)$，$n=1,2,\cdots,N$。<br>似然函数为</p><script type="math/tex; mode=display">p(\textbf{t}|\pmb{w})=\prod_{n=1}^Ny_n^{t_n}(1-y_n)^{1-t_n}</script><p>其中，$\textbf{t}=(t_1,t_2,\cdots,t_N)^\top$。<strong>通过对似然函数取负对数的方式定义一个误差函数，即交叉熵（cross-entropy）误差函数</strong></p><script type="math/tex; mode=display">E(\pmb{w})=-\ln p(\textbf{t}|\pmb{w})=-\sum_{n=1}^N\{t_n\ln y_n+(1-t_n)\ln(1-y_n)\}</script><p>对$\pmb{w}$求梯度，可得</p><script type="math/tex; mode=display">\nabla E(\pmb{w})=\sum_{n=1}^N(y_n-t_n)\pmb{\phi}_n=\Phi^\top(\textbf{y}-\textbf{t})</script><p><strong>注：</strong>最大似然方法对于线性可分的数据集会产生严重的过拟合。</p><h2 id="迭代重加权最小平方（IRLS）"><a href="#迭代重加权最小平方（IRLS）" class="headerlink" title="迭代重加权最小平方（IRLS）"></a>迭代重加权最小平方（IRLS）</h2><p>logistic回归不再有解析解，故需要用Newton-Raphson迭代</p><script type="math/tex; mode=display">\pmb{w}^{new}=\pmb{w}^{old}-H^{-1}\nabla E(\pmb{w})</script><p>其中，$H$是Hessian矩阵，其元素为$E(\pmb{w})$关于$\pmb{w}$的二阶导数。<br>推导可得</p><script type="math/tex; mode=display">H=\nabla\nabla E(\pmb{w})=\sum_{n=1}^Ny_n(1-y_n)\pmb{\phi}_n\pmb{\phi}_n^\top=\Phi^\top R\Phi</script><p>其中，$N\times N$的对角矩阵$R$元素为$R_{nn}=y_n(1-y_n)$。由于$o&lt;y_n&lt;1$，故对任意向量$u$都有$u^\top Hu&gt;0$，即$H$正定，因此误差函数是$\pmb{w}$的凸函数，有唯一最小值。</p><h2 id="softmax分类"><a href="#softmax分类" class="headerlink" title="softmax分类"></a>softmax分类</h2><p>对于多分类问题，后验概率为</p><script type="math/tex; mode=display">p(C_k|\pmb{\phi})=y_k(\pmb{\phi})=\frac{\exp(a_k)}{\sum_j\exp(a_j)}</script><p>其中，$a_k=\pmb{w}_k^\top\pmb{\phi}$。求导，有</p><script type="math/tex; mode=display">\frac{\partial y_k}{\partial a_j}=\begin{cases} y_k(1-y_k), & j=k \\ -y_ky_j, & j\neq k \end{cases}</script><p>从而，似然函数为</p><script type="math/tex; mode=display">p(T|\pmb{w}_1,\cdots,\pmb{w}_K)=\prod_{n=1}^N\prod_{k=1}^Kp(C_k|\pmb{\phi}_n)^{t_{nk}}=\prod_{n=1}^N\prod_{k=1}^Ky_{nk}^{t_{nk}}</script><p>其中，$y_{nk}=y_k(\pmb{\phi}_n)$，$T$是一个$N\times K$的矩阵，元素$t_{nk}$为1-of-K编码值。<br>交叉熵误差函数为</p><script type="math/tex; mode=display">E(\pmb{w}_1,\cdots,\pmb{w}_K)=-\ln p(T|\pmb{w}_1,\cdots,\pmb{w}_K)=-\sum_{n=1}^N\sum_{k=1}^Kt_{nk}\ln y_{nk}</script><p>同样利用Newton-Raphson迭代可求解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xueshu.baidu.com/s?wd=paperuri%3A%28039d5c0802df10a9c04decf174c5409d%29&amp;filter=sc_long_sign&amp;sc_ks_para=q%3DPattern%20Recognition%20and%20Machine%20Learning%20%28Information%20Science%20and%20Statistics%29&amp;sc_us=9652015233931872413&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8" target="_blank" rel="noopener">“Pattern Recognition and Machine Learning”</a></p>]]></content>
      
      
      <categories>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python命令行解析器argparse的使用</title>
      <link href="/2018/10/argparse.html"/>
      <url>/2018/10/argparse.html</url>
      
        <content type="html"><![CDATA[<p>argparse是Python内置的一个用于命令项选项与参数解析的模块，在编写脚本的过程中是非常常用的。<br>在其使用中主要包含三个步骤：<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'this is a process for read file'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'fileinPath'</span>, help=<span class="string">'path to input file'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'fileoutPath'</span>, help=<span class="string">'path to output file'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure></p><p>而当如上定义后，即可在需要用到参数的地方调用<code>args.fileinPath</code>和<code>args.fileoutPath</code>。下面详细讲解一下<code>add_argument()</code>方法。</p><h2 id="add-argument-方法"><a href="#add-argument-方法" class="headerlink" title="add_argument()方法"></a><code>add_argument()</code>方法</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>位置参数是必选参数，如果命令行解析不到就会报错，上面例子中两个参数都是位置参数。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数可以填写两种，长的可选参数以及短的，并且可以并存，会首先解析长可选参数。如：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'-s'</span>, <span class="string">'--square'</span>, help=<span class="string">'display a square of a given number'</span>, type=int)</span><br></pre></td></tr></table></figure></p><p>当然在一个脚本中，位置参数与可选参数是可以并存的。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>给一个整数序列，输出它们的和或最大值（默认）<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                   help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                   const=sum, default=max,</span><br><span class="line">                   help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure></p><p>则在调用的时候：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; python test.py</span></span><br><span class="line">usage: test.py [-h] [--sum] N [N ...]</span><br><span class="line">test.py: error: the following arguments are required: N</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; python test.py -h</span></span><br><span class="line">usage: test.py [-h] [--sum] N [N ...]</span><br><span class="line"></span><br><span class="line">Process some integers.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  N           an integer for the accumulator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br><span class="line">  --sum       sum the integers (default: find the max)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; python test.py 1 2 3 4</span></span><br><span class="line">4</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; python test.py 1 2 3 4 --sum</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><h3 id="所有参数"><a href="#所有参数" class="headerlink" title="所有参数"></a>所有参数</h3><ul><li><code>name or flags</code> - 选项字符串的名字或者列表，例如<code>foo</code>或者<code>-f</code>，<code>--foo</code>；</li><li><p><code>action</code> - 命令行遇到参数时的动作，默认值是<code>store</code>；</p><ul><li><code>store_const</code>，表示赋值为<code>const</code>。意思为如果能解析到该参数，则该参数赋值为<code>const</code>的值，见上个例子；</li><li><code>store_true</code>和<code>store_false</code>，参数默认值分别为<code>False</code>和<code>True</code>。意思为如果能解析到该参数，则参数值分别改为<code>True</code>和<code>False</code>；</li><li><p><code>append</code>，将遇到的值存储成<code>list</code>，也就是如果参数重复则会保存多个值。如：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import argparse</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser = argparse.ArgumentParser()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'append'</span>, <span class="built_in">type</span>=int)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.parse_args(<span class="string">'--foo 1 --foo 2'</span>.split())</span></span><br><span class="line">Namespace(foo = [1, 2])</span><br></pre></td></tr></table></figure></li><li><p><code>append_const</code>，将固定值保存成一个<code>list</code>。意思为如果能解析道该参数，则<code>list</code>将会<code>append</code>一个<code>const</code>进来。如：</p>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--str'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=str)</span><br><span class="line">parser.add_argument(<span class="string">'--int'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=int)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">print(args)</span><br></pre></td></tr></table></figure><p>  在命令行：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; python test.py --str --str --int</span></span><br><span class="line">Namespace(types=[&lt;class 'str'&gt;, &lt;class 'str'&gt;, &lt;class 'int'&gt;])</span><br></pre></td></tr></table></figure></li><li><p><code>count</code>，存储遇到的参数次数。</p></li><li><p><code>nrgs</code> - 应该读取的命令行参数个数，可以是具体的数字、<code>*</code>、<code>+</code>和<code>?</code>。<code>*</code>表示0个或多个；<code>+</code>表示1个或多个；<code>?</code>时，若解析不到参数，则使用<code>default</code>值，对于可选参数，若只写了参数名而后面没有值，则使用<code>const</code>值。如</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser = argparse.ArgumentParser()</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, const=<span class="string">'c'</span>, default=<span class="string">'d'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>, default=<span class="string">'d'</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.parse_args([<span class="string">'XX'</span>, <span class="string">'--foo'</span>, <span class="string">'YY'</span>])</span></span><br><span class="line">Namespace(bar='XX', foo='YY')</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.parse_args([<span class="string">'XX'</span>, <span class="string">'--foo'</span>])</span></span><br><span class="line">Namespace(bar='XX', foo='c')</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; parser.parse_args([])</span></span><br><span class="line">Namespace(bar='d', foo='d')</span><br></pre></td></tr></table></figure><p><strong>注：</strong><code>nargs=1</code>会将参数存放为<code>list</code>，不同于不设置；对参数加<code>nargs=&#39;*&#39;</code>或<code>nargs=&#39;+&#39;</code>在一定程度可以代替<code>action=&#39;append&#39;</code>。</p></li></ul></li><li><code>const</code> - <code>action</code>和<code>nargs</code>所需要的常量值；</li><li><code>default</code> - 不指定参数时的默认值；</li><li><code>type</code> - 命令行参数应该被转换成的类型；</li><li><code>choices</code> - 参数可允许的值的一个容器。可以是<code>list</code>和<code>range</code>；</li><li><code>required</code> - 可选参数是否可以省略 (仅针对可选参数)。如果设置<code>required=&#39;True&#39;</code>，则可选参数解析不到时报错；</li><li><code>metavar</code> - 在 usage 说明中的参数名称，对于位置参数默认就是参数名称，对于可选参数默认是全大写的参数名称；</li><li><code>dest</code> - 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wiki.jikexueyuan.com/project/explore-python/Standard-Modules/argparse.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/explore-python/Standard-Modules/argparse.html</a><br><a href="https://docs.python.org/3/library/argparse.html#the-add-argument-method" target="_blank" rel="noopener">https://docs.python.org/3/library/argparse.html#the-add-argument-method</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git常用命令</title>
      <link href="/2018/10/git.html"/>
      <url>/2018/10/git.html</url>
      
        <content type="html"><![CDATA[<p>让我们一起学习如何使用git进行版本管理吧！<br><a id="more"></a></p><style>table th:nth-of-type(2) {    width: 300px;}</style><div class="table-container"><table><thead><tr><th>操作</th><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>将远程仓库克隆到本地</td><td>git clone ‘url’</td><td>url地址可选SSH或HTTPS</td></tr><tr><td>创建新的本地仓库</td><td>git init</td><td></td></tr><tr><td>添加文件或目录到索引</td><td>git add ‘filepattern’</td><td>filepattern可以指定多个文件名，或指定通配字符（如’.txt’），’.’代表所有文件</td></tr><tr><td>提交追加到索引的文件</td><td>git commit -m ‘info’</td><td>-m参数将’info’内容作为提交注释</td></tr><tr><td>显示修改文件清单</td><td>git status</td><td></td></tr><tr><td>查看修改文件的差异</td><td>git diff</td><td></td></tr><tr><td>显示提交记录</td><td>git log</td><td></td></tr><tr><td>修改，移动文件的名称或目录的名称</td><td>git mv ‘oldfilename’ ‘newfilename’</td><td></td></tr><tr><td>删除文件</td><td>git rm ‘filename’</td><td></td></tr><tr><td>还原文件修改</td><td>git checkout - -‘filename’</td><td>若文件未添加到索引，则恢复到与版本库一致状态；若已添加至索引，则恢复到添加之后修改之前的状态</td></tr><tr><td>删除已添加到索引的文件</td><td>git reset HEAD - -‘filename’</td><td></td></tr><tr><td>在本地添加远程库</td><td>git remote add origin ‘url’</td><td></td></tr><tr><td>显示远程数据库列表</td><td>git remote -v</td><td>-v参数表示列出仓库的详细情况</td></tr><tr><td>查看已有分支</td><td>git branch -av</td><td>当前分支前会显示*</td></tr><tr><td>创建分支</td><td>git branch -b ‘branchname’</td><td>-b参数表示创建并切换</td></tr><tr><td>切换到某分支</td><td>git checkout ‘branch’</td><td></td></tr><tr><td>把当前分支推送到远程</td><td>git push -u ‘remote’ ‘branch’</td><td>例git push -u origin master</td></tr><tr><td>查看远程仓库修改内容，并合并到本地库</td><td>git pull ‘remote’ ‘branch’</td><td>若省略’branch’则当前分支作为合并目标</td></tr><tr><td>查看远程仓库修改内容，但不合并到本地库</td><td>git fetch ‘remote’</td><td></td></tr><tr><td>合并某分支到当前分支</td><td>git merge - -no-ff ‘branch’</td><td>- -no-ff参数表示禁止fast-forward模式</td></tr><tr><td>删除分支</td><td>git branch -d ‘branchname’</td></tr></tbody></table></div><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2F&amp;parentPath=%2F" target="_blank" rel="noopener">Git Cheat Sheet</a><br><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都能懂的git入门</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰git教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python中list的查找</title>
      <link href="/2018/10/list-index.html"/>
      <url>/2018/10/list-index.html</url>
      
        <content type="html"><![CDATA[<p>Python中查找list中某个固定元素是常有的事，对于两种不同的查找有两种不同的解决方案，见下。</p><h2 id="查找元素首次出现的位置"><a href="#查找元素首次出现的位置" class="headerlink" title="查找元素首次出现的位置"></a>查找元素首次出现的位置</h2><p>list自带的方法index可以找出某元素在list中首次出现的位置。用法为<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.index(element, start, end)</span><br></pre></td></tr></table></figure></p><p>其中，<code>start</code>为开始搜索的位置，默认为0；<code>end</code>为结束搜索的位置，默认为list长度。示例：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">res = l.index(<span class="number">1</span>)</span><br><span class="line">print(res, type(res))</span><br></pre></td></tr></table></figure></p><p>则输出结果为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;class 'int'&gt;</span><br></pre></td></tr></table></figure></p><p>若限定搜索范围（可只指定其中某一个）：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">res = l.index(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">print(res, type(res))</span><br></pre></td></tr></table></figure></p><p>则输出结果为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 &lt;class 'int'&gt;</span><br></pre></td></tr></table></figure></p><h2 id="查找元素出现的所有位置"><a href="#查找元素出现的所有位置" class="headerlink" title="查找元素出现的所有位置"></a>查找元素出现的所有位置</h2><p>若想找出某一元素在该list中的所有出现位置，则用一个循环来简单的实现。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">res = [idx <span class="keyword">for</span> idx, i <span class="keyword">in</span> l <span class="keyword">if</span> i == <span class="number">1</span>]</span><br><span class="line">print(res, type(res))</span><br></pre></td></tr></table></figure></p><p>则输出结果为<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 3] &lt;class 'list'&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo中的LaTex公式渲染问题</title>
      <link href="/2018/10/hexo-latex.html"/>
      <url>/2018/10/hexo-latex.html</url>
      
        <content type="html"><![CDATA[<p>Markdown中插入数学公式是常有的事，而Hexo博客框架主要是Markdown格式的文档，如果不能正常渲染Latex公式，那岂不gg……<br>下面来看看Hexo渲染数学公式遇到的问题以及解决方案。</p><h2 id="渲染下划线的问题"><a href="#渲染下划线的问题" class="headerlink" title="渲染下划线的问题"></a>渲染下划线的问题</h2><a id="more"></a><p><code>_</code>在Latex公式中代表脚标，是非常常用的符号，而在Markdown中代表<em>斜体</em>，如果直接使用，将会产生公式无法渲染的问题，因为被Hexo强制渲染成了<code>&lt;em&gt;</code>标签。<br>如何解决呢？<strong>更换Hexo默认的Markdown渲染引擎！</strong><br>Hexo默认的渲染引擎为hexo-renderer-marked，这里将其更换为hexo-renderer-kramed，该引擎在前者的基础上修复了一些bug，具体操作：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><h2 id="行内公式的问题"><a href="#行内公式的问题" class="headerlink" title="行内公式的问题"></a>行内公式的问题</h2><p>执行上述操作后，虽然块状公式的渲染问题解决了，但发现行内公式仍然是老样子，无法成功渲染，这是因为hexo-renderer-kramed也有语义冲突的问题，这里我们直接修改转义即可。打开文件<code>\node_modules\kramed\lib\rules\inline.js</code>，修改其中一行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">  em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure></p><p>把之前的<code>em</code>转义注释掉，添加新的即可完美解决。</p><h2 id="双花括号的问题"><a href="#双花括号的问题" class="headerlink" title="双花括号的问题"></a>双花括号的问题</h2><p>除此之外，如果在公式内连续使用两个花括号，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\frac&#123;1&#125;&#123;&#123;(2\pi)&#125;^\frac&#123;D&#125;&#123;2&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>时会渲染失败</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw6fw1wt83j31080p6nah.jpg" width="50%" height="50%"></center><br>此时必须在两个花括号中间加一个<strong>空格</strong>，<code>\frac{1}{ {(2\pi)}^\frac{D}{2} }</code>即可正常渲染$\frac{1}{ {(2\pi)}^\frac{D}{2} }$<br><strong>注</strong>：上述操作完成后均需重启Hexo，即<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">https://www.jianshu.com/p/7ab21c7f0674</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> Hexo </tag>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性分类模型(二)——生成式模型</title>
      <link href="/2018/10/linear-classification2.html"/>
      <url>/2018/10/linear-classification2.html</url>
      
        <content type="html"><![CDATA[<p>生成式方法：对<strong>类条件概率密度</strong>$p(\pmb{x}|C_k)$和<strong>类先验概率分布</strong>$p(C_k)$建模，然后使用贝叶斯定理计算后验概率密度$p(C_k|\pmb{x})$，从而进行预测。<br><a id="more"></a></p><h2 id="二分类模型"><a href="#二分类模型" class="headerlink" title="二分类模型"></a>二分类模型</h2><p>类别$C_1$的后验概率为</p><script type="math/tex; mode=display">p(C_1|\pmb{x})=\frac{p(\pmb{x}|C_1)p(C_1)}{p(\pmb{x}|C_1)p(C_1)+p(\pmb{x}|C_2)p(C_2)}=\frac{1}{1+\exp(-a)}\triangleq\sigma(a)</script><p>其中，$a=\ln\frac{p(\pmb{x}|C_1)p(C_1)}{p(\pmb{x}|C_2)p(C_2)}$，$\sigma(a)$是sigmoid函数。<br>假设类条件概率密度是高斯分布，且所有的类别协方差阵相同。则</p><script type="math/tex; mode=display">p(\pmb{x}|C_k)=\frac{1}{ {(2\pi)}^\frac{D}{2} }\frac{1}{|\Sigma|^\frac{1}{2}}\exp\{-\frac{1}{2}(\pmb{x}-\pmb{\mu}_k)^\top\Sigma^{-1}(\pmb{x}-\pmb{\mu}_k)\}</script><p>则后验可化为</p><script type="math/tex; mode=display">p(C_1|\pmb{x})=\sigma(\pmb{w}^\top\pmb{x}+w_0)</script><p>其中，定义了$\pmb{w}=\Sigma^{-1}(\pmb{\mu}_1-\pmb{\mu}_2)$，$w_0=-\frac{1}{2}\pmb{\mu}_1^\top\Sigma^{-1}\pmb{\mu}_1+\frac{1}{2}\pmb{\mu}_2^\top\Sigma^{-1}\pmb{\mu}_2+\ln\frac{p(C_1)}{p(C_2)}$</p><h2 id="多分类模型"><a href="#多分类模型" class="headerlink" title="多分类模型"></a>多分类模型</h2><p>类别$C_k$的后验概率为</p><script type="math/tex; mode=display">p(C_k|\pmb{x})=\frac{p(\pmb{x}|C_k)p(C_k)}{\sum_jp(\pmb{x}|C_j)p(C_j)}=\frac{\exp(a_k)}{\sum_j\exp(a_j)}\triangleq softmax_k(\pmb{a})</script><p>其中，$a_k=\ln (p(\pmb{x}|C_k)p(C_k))$。<br>在同样的高斯分布和类别协方差阵假设下，有</p><script type="math/tex; mode=display">a_k(\pmb{x})=\pmb{w}_k^\top\pmb{x}+w_{k0}</script><p>其中，$\pmb{w}_k=\Sigma^{-1}\pmb{\mu}_k$，$w_{k0}=-\frac{1}{2}\pmb{\mu}_k^\top\Sigma^{-1}\pmb{\mu}_k+\ln p(C_k)$</p><h2 id="极大似然解"><a href="#极大似然解" class="headerlink" title="极大似然解"></a>极大似然解</h2><p>首先考虑二分类的情形。<br>假设有一个数据集$\{\pmb{x}_n,t_n\}$，其中$n=1,2,\cdots,N$。$t_n=1,0$分别表示类别$C_1,C_2$，把先验记为$p(C_1)=\pi$，则有</p><script type="math/tex; mode=display">p(\pmb{x}_n,C_1)=p(C_1)p(\pmb{x}_n|C_1)=\pi\mathscr{N}(\pmb{x}_n|\pmb{\mu}_1,\Sigma)</script><p>根据全概率公式可得<strong>似然函数</strong>为</p><script type="math/tex; mode=display">p(\textbf{t}|\pi,\mu_1,\mu_2,\Sigma)=\prod_{n=1}^{N}[\pi\mathscr{N}(\pmb{x}_n|\pmb{\mu}_1,\Sigma)]^{t_n}[(1-\pi)\mathscr{N}(\pmb{x}_n|\pmb{\mu}_2,\Sigma)]^{1-t_n}</script><p>其中，$\textbf{t}=(t_1,t_2,\cdots,t_N)^\top$。<br>分别对各个参数求导可得极大似然解为</p><script type="math/tex; mode=display">\pi=\frac{1}{N}\sum_{n=1}^Nt_n=\frac{N_1}{N}\\\pmb{\mu}_1=\frac{1}{N_1}\sum_{n=1}^Nt_n\pmb{x}_n\\\pmb{\mu}_2=\frac{1}{N_2}\sum_{n=1}^N(1-t_n)\pmb{x}_n\\\Sigma=S=\frac{N_1}{N}S_1+\frac{N_2}{N}S_2</script><p>其中，$S_1=\frac{1}{N_1}\sum_{n\in C_1}(\pmb{x}_n-\pmb{\mu}_1)(\pmb{x}_n-\pmb{\mu}_1)^\top$，$S_2=\frac{1}{N_2}\sum_{n\in C_2}(\pmb{x}_n-\pmb{\mu}_2)(\pmb{x}_n-\pmb{\mu}_2)^\top$。详细求解过程见参考。<br>而对于多分类问题，很容易得到极大似然解。<br><strong>注</strong>：该方法对于离群点不鲁棒。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xueshu.baidu.com/s?wd=paperuri%3A%28039d5c0802df10a9c04decf174c5409d%29&amp;filter=sc_long_sign&amp;sc_ks_para=q%3DPattern%20Recognition%20and%20Machine%20Learning%20%28Information%20Science%20and%20Statistics%29&amp;sc_us=9652015233931872413&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8" target="_blank" rel="noopener">“Pattern Recognition and Machine Learning”</a></p>]]></content>
      
      
      <categories>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性分类模型(一)——线性判别函数</title>
      <link href="/2018/10/linear-classification1.html"/>
      <url>/2018/10/linear-classification1.html</url>
      
        <content type="html"><![CDATA[<p>线性分类模型主要有四种不同的方法，线性判别函数、生成式模型、判别式模型以及贝叶斯观点下的Logistic回归。我们直接考虑对原始输入空间$\pmb{x}$进行分类，当然也适用于对输入变量进行一个固定的变换$\phi(\pmb{x})$。<br>判别函数是一个以向量$\pmb{x}$为输入，把它直接分配到$K$个类别中的某一个类别（$C_k$）的函数。<br><a id="more"></a></p><h2 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h2><p>线性判别函数为</p><script type="math/tex; mode=display">y(\pmb{x})=\pmb{w}^\top\pmb{x}+w_0</script><p>如果$y(\pmb{x})\geqslant0$，则它被分到$C_1$中，否则被分到$C_2$中。</p><h2 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h2><h3 id="造成困难的方法"><a href="#造成困难的方法" class="headerlink" title="造成困难的方法"></a>造成困难的方法</h3><p><strong>‘one-versus-the-rest’</strong>方法使用$K-1$个分类器，每个分类器是一个二分类问题，分开属于$C_k$和不属于的部分。但是可能会产生输入空间无法分类的区域，如图所示。</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw27x8xbuuj30r80nyjsm.jpg" width="50%"></center><br><strong>‘one-versus-one’</strong>方法使用$\frac{K(K-1)}{2}$个分类器，每个数据点的类别根据这些判别函数中的大多数输出类别确定。但是这也可能会产生输入空间无法分类的区域，如图所示。</p><p><center><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw27zv6m6mj30ne0myta5.jpg" width="50%"></center></p><h3 id="正确的方法"><a href="#正确的方法" class="headerlink" title="正确的方法"></a>正确的方法</h3><p>引入一个$K$类判别函数可以避免上述问题。该函数由$K$个线性函数构成：</p><script type="math/tex; mode=display">y_k(\pmb{x})=\pmb{w}_k^\top\pmb{x}+w_{k0}</script><p>对于一个数据点$\pmb{x}$，如果$y_k(\pmb{x})$最大，就把它分到$C_k$中。于是类别$C_k$与$C_j$之间的决策面为$y_k(\pmb{x})=y_j(\pmb{x})$。这样的决策区域总是单连通的，并且是凸的。<br>对于二分类问题也可以构造基于两个线性函数$y_1(\pmb{x})$和$y_2(\pmb{x})$的判别函数，只是前述方法更简单且是等价的。</p><h3 id="分类的最小平方法（Least-Squares）求解参数矩阵"><a href="#分类的最小平方法（Least-Squares）求解参数矩阵" class="headerlink" title="分类的最小平方法（Least Squares）求解参数矩阵"></a>分类的最小平方法（Least Squares）求解参数矩阵</h3><p>对于一个一般的$K$分类问题，每个类别$C_k$有一个线性模型</p><script type="math/tex; mode=display">y_k(\pmb{x})=\pmb{w}_k^\top\pmb{x}+w_{k0}</script><p>使用矩阵记号</p><script type="math/tex; mode=display">\pmb{y}(\pmb{x})=\tilde{W}^\top\tilde{\pmb{x}}</script><p>其中，$W^\top=(\tilde{\pmb{w}}_1,\tilde{\pmb{w}}_2,\cdots,\tilde{\pmb{w}}_K)^\top$每行为$\tilde{\pmb{w}}_k^\top$，$\tilde{\pmb{w}}_k=(w_{k0},\pmb{w}_k^\top)^\top$为列向量，$\tilde{\pmb{x}}=(1,\pmb{x}^\top)^\top$为列向量。<br>一个新的输入$\pmb{x}$将被分到$y_k(\pmb{x})=\tilde{\pmb{w}}_k^\top\tilde{\pmb{x}}$最大的类别中。<br>对于训练集${\pmb{x}_n,\pmb{t}_n}$，其中$n=1,2,\cdots,N$，平方和误差函数为</p><script type="math/tex; mode=display">E_D(\tilde{W})=\frac{1}{2}Tr\{(\tilde{X}\tilde{W}-T)^\top(\tilde{X}\tilde{W}-T)\}</script><p>其中，$\tilde{X}=(\tilde{\pmb{x}}_1^\top,\tilde{\pmb{x}}_2^\top,\cdots,\tilde{\pmb{x}}_N^\top)^\top$，$T=(\tilde{\pmb{t}}_1^\top,\tilde{\pmb{t}}_2^\top,\cdots,\tilde{\pmb{t}}_N^\top)^\top$采用‘1-of-K’表示方式。求导可得参数矩阵最优解为</p><script type="math/tex; mode=display">\tilde{W}=(\tilde{X}^\top\tilde{X})^{-1}\tilde{X}^\top T=\tilde{X}^\dagger T</script><p>即可得判别函数为</p><script type="math/tex; mode=display">\pmb{y}(\pmb{x})=\tilde{W}^\top\tilde{\pmb{x}}=T^\top(\tilde{X}^\dagger)^\top\tilde{\pmb{x}}</script><p>然而，最小平方解对于离群点缺少鲁棒性，且通常不会给出较好的结果，这与高斯条件分布假设有关。</p><h2 id="Fisher线性判别函数"><a href="#Fisher线性判别函数" class="headerlink" title="Fisher线性判别函数"></a>Fisher线性判别函数</h2><p>针对二分类问题，我们将数据投影到一维，通过调整权向量，使类别之间分开最大。投影式为</p><script type="math/tex; mode=display">y=\pmb{w}^\top\pmb{x}</script><p>当得到最佳的投影之后，只需设置一个恰当的阈值即可将样本分类。<br>投影之后的类别均值差为</p><script type="math/tex; mode=display">m_2-m_1=\pmb{w}^\top(\pmb{m}_2-\pmb{m}_1)</script><p>其中，$\pmb{m}_1$和$\pmb{m}_2$为原始数据的类别均值向量，此处限制$\pmb{w}$为单位长度，即$\sum_iw_i^2=1$。<br>Fisher思想：最大化一个函数，使得类均值的投影分开较大，类内的方差较小。<br><strong>Fisher准则</strong>根据类间方差和类内方差的比值定义：</p><script type="math/tex; mode=display">J(\pmb{w})=\frac{(m_2-m_1)^2}{s_1^2+s_2^2}</script><p>其中，投影后的一维类内方差为$s_k^2=\sum_{n\in C_k}(y_n-m_k)^2$，$y_n=\pmb{w}^\top\pmb{x}_n$。<br>化简可得</p><script type="math/tex; mode=display">J(\pmb{w})=\frac{\pmb{w}^\top S_B\pmb{w}}{\pmb{w}^\top S_W\pmb{w}}</script><p>其中，$S_B$和$S_W$分别为类间协方差阵和类内协方差阵</p><script type="math/tex; mode=display">S_B=(\pmb{m}_2-\pmb{m}_1)(\pmb{m}_2-\pmb{m}_1)^\top \\S_W=\sum_{n\in C_1}(\pmb{x}_n-\pmb{m}_1)(\pmb{x}_n-\pmb{m}_1)^\top+\sum_{n\in C_2}(\pmb{x}_n-\pmb{m}_2)(\pmb{x}_n-\pmb{m}_2)^\top</script><p>对$J(\pmb{w})$求导可得</p><script type="math/tex; mode=display">(\pmb{w}^\top S_B\pmb{w})S_W\pmb{w}=(\pmb{w}^\top S_W\pmb{w})S_B\pmb{w}\\\pmb{w}\propto S_W^{-1}(\pmb{m}_2-\pmb{m}_1)</script><p>若类内协方差阵是各向同性的，则$S_W$正比于单位矩阵，$\pmb{w}$正比于原始数据的类均值差。<br>对于多分类问题，也有对应的Fisher判别函数。</p><h2 id="感知器算法"><a href="#感知器算法" class="headerlink" title="感知器算法"></a>感知器算法</h2><p>对输入向量先进行一个固定的非线性变换再构造一个线性模型，为</p><script type="math/tex; mode=display">y(\pmb{x})=f(\pmb{w}^\top\phi(\pmb{x}))</script><p>其中，$f(·)$为一个阶梯函数</p><script type="math/tex; mode=display">f(a)= \begin{cases} 1, & a\geqslant0 \\ -1, & a<0 \end{cases}</script><p>此处我们使用$t=+1$表示$C_1$，$t=-1$表示$C_2$。<br>我们需要找到合适的权向量$\pmb{w}$使得对所有的数据点有$\pmb{w}^\top\phi(\pmb{x}_n)\pmb{t}_n&gt;0$。<br><strong>感知器准则</strong>：对于误分类的数据$\pmb{x}_n$赋予误差，则误差函数为</p><script type="math/tex; mode=display">E_P(\pmb{w})=-\sum_{n\in \mathscr{M}}\pmb{w}^\top\phi_n\pmb{t}_n</script><p>其中，$\mathscr{M}$表示所有误分类数据的集合。对该误差函数使用随机梯度下降（SGD）</p><script type="math/tex; mode=display">\pmb{w}^{(\tau+1)}=\pmb{w}^{(\tau)}-\eta\nabla E_P(\pmb{w})=\pmb{w}^{(\tau)}+\eta\phi_n\pmb{t}_n</script><p>由于$f(·)$的设置，不失一般性可设$\eta=1$。<strong>则实际上SGD变为了：如果该数据点分类正确，则权向量保持不变；如果分类错误，对于类别$C_1$，把向量$\phi(\pmb{x}_n)$加到当前的权向量上得到新的权向量，对于类别$C_2$，则从当前的权向量中减掉$\phi(\pmb{x}_n)$得到新的权向量。</strong><br><strong>注</strong>：感知器学习规则并不保证在每个阶段都会减小整体误差。但由感知器收敛定理，如果训练数据线性可分，那么感知器算法可以保证在有限步骤内找到精确解。对于线性不可分数据，则永远不会收敛。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://xueshu.baidu.com/s?wd=paperuri%3A%28039d5c0802df10a9c04decf174c5409d%29&amp;filter=sc_long_sign&amp;sc_ks_para=q%3DPattern%20Recognition%20and%20Machine%20Learning%20%28Information%20Science%20and%20Statistics%29&amp;sc_us=9652015233931872413&amp;tn=SE_baiduxueshu_c1gjeupa&amp;ie=utf-8" target="_blank" rel="noopener">“Pattern Recognition and Machine Learning”</a></p>]]></content>
      
      
      <categories>
          
          <category> 术业专攻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python中正则表达式的特殊字符</title>
      <link href="/2018/09/re.html"/>
      <url>/2018/09/re.html</url>
      
        <content type="html"><![CDATA[<p>Python的 <strong>re</strong> 模块提供了正则表达式匹配的功能，其中经常会用到一些特殊字符，下面罗列它们以及各自的用法。</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><ul><li><code>.</code>：匹配除了换行符<code>\n</code>之外的任何字符；</li><li><code>^</code>：匹配字符串的开头（需放到正则表达式开头）；</li><li><code>$</code>：匹配字符串的结尾（需放到正则表达式结尾）；<a id="more"></a></li><li><code>*</code>：匹配前一个表达式0次或多次。例如：<code>ab*</code>可匹配<code>a</code>，<code>ab</code>或<code>abbbbbbbbb</code>等；</li><li><code>+</code>：匹配前一个表达式1次或多次。例如：<code>ab*</code>可匹配<code>ab</code>或<code>abbbbbbbbb</code>等；</li><li><code>?</code>：匹配前一个表达式0次或1次。例如：<code>ab?</code>可匹配<code>a</code>和<code>ab</code>；</li><li><code>{m}</code>：精确匹配前一个表达式m次。例如：<code>ab{2}c</code>不能匹配<code>abc</code>，但却能匹配<code>abbc</code>。<strong>实测：可以匹配小于m个，但不能匹配大于m个，Why?</strong>，例如：<code>ab{2}</code>可以匹配<code>abbbbbc</code>，So精确模式？</li><li><code>{m,}</code>：匹配前一个表达式至少m次，贪婪模式（尽可能多的匹配）；</li><li><code>{m,n}</code>：匹配前一个表达式m到n次，贪婪模式；</li><li><code>{m,n}?</code>：匹配前一个表达式m到n次，非贪婪模式（尽可能少的匹配）；</li><li><code>[…]</code>：用来表示一组字符<ul><li>匹配其中的单个字符。例如：<code>[abc]</code>将会匹配<code>a</code>，<code>b</code>或<code>c</code>；</li><li>匹配一个范围，通过<code>-</code>表示。例如：<code>[a-z]</code>表示匹配任何小写字母，<code>[0-9][0-9]</code>表示匹配任意二位数字</li><li><code>[^…]</code>将匹配不在<code>[]</code>中的字符。例如：<code>[^abc]</code>将匹配除了<code>a</code>，<code>b</code>和<code>c</code>之外的字符。</li></ul></li><li><code>a|b</code>：匹配<code>a</code>或<code>b</code>；</li><li><code>(…)</code>：匹配括号内的表达式，作为一个整体；</li><li><code>\w</code>：匹配字母数字及下划线，等价于<code>[a-zA-Z0-9_]</code>；</li><li><code>\W</code>：匹配非字母数字及下划线，等价于<code>[^a-zA-Z0-9_]</code>；</li><li><code>\s</code>：匹配任意空白字符，等价于<code>[\t\n\r\f\v]</code><a href="#bib1" id="bib1ref"><sup>[1]</sup></a>；</li><li><code>\S</code>：匹配任意非空字符，等价于<code>[^\t\n\r\f\v]</code>；</li><li><code>\d</code>：匹配任意数字，等价于<code>[0-9]</code>；</li><li><code>\D</code>：匹配任意非数字，等价于<code>[^0-9]</code>。</li></ul><h2 id="巧用"><a href="#巧用" class="headerlink" title="巧用?"></a>巧用<code>?</code></h2><p>正则表达式中<code>*</code>，<code>+</code>和<code>?</code>都是贪婪的，它们尽可能多的匹配，但实际使用中有时并不可取。通过对其加一个<code>?</code>来限制匹配的次数，达到非贪婪的效果。<br>例如，原文本为：</p><blockquote><p>str = ‘AAsuixinBBAAsuixinBB’</p></blockquote><p>使用贪婪表达式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(<span class="string">r'AA(.+)BB'</span>, str)</span><br><span class="line">print(res.group())</span><br></pre></td></tr></table></figure></p><p>将会输出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAsuixinBBAAsuixinBB</span><br></pre></td></tr></table></figure></p><p>使用非贪婪模式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(<span class="string">r'AA(.+?)BB'</span>, str)</span><br><span class="line">print(res.group())</span><br></pre></td></tr></table></figure></p><p>将会输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAsuixinBB</span><br></pre></td></tr></table></figure></p><h3 id="与"><a href="#与" class="headerlink" title=".+?与.*?"></a><code>.+?</code>与<code>.*?</code></h3><ul><li>都是非贪婪匹配任意字符；</li><li><code>.+?</code>必须匹配到至少一个任意字符，而<code>.*?</code>可以匹配到0次。例如，<code>合理使用Python中正则表达式的特殊字符</code>，无论‘合理’与‘使用’之间有没有‘的’，使用<code>.*?</code>均可匹配到结果，而使用<code>.+?</code>将返回None。</li></ul><h2 id="re中常用的四个函数findall，match，search和sub"><a href="#re中常用的四个函数findall，match，search和sub" class="headerlink" title="re中常用的四个函数findall，match，search和sub"></a>re中常用的四个函数findall，match，search和sub</h2><h3 id="re-findall-pattern-string-flags-0"><a href="#re-findall-pattern-string-flags-0" class="headerlink" title="re.findall(pattern, string, flags=0)"></a>re.findall(pattern, string, flags=0)</h3><p>在string中从左到右匹配所有符合情况的字符串，返回一个list，如果没有匹配到，则返回一个空的list。其中flags表示匹配模式，比如忽略大小写，多行模式等。</p><h3 id="re-match-pattern-string-flags-0"><a href="#re-match-pattern-string-flags-0" class="headerlink" title="re.match(pattern, string, flags=0)"></a>re.match(pattern, string, flags=0)</h3><p>从字符串开头进行匹配，返回<strong>“匹配对象”</strong>，如果未匹配到，则返回None。<br><strong>“匹配对象”</strong>：布尔值为True，使用<code>.group()</code>或<code>.group(0)</code>返回匹配得到的字符串，使用<code>.group(1)</code>返回匹配的第一个括号内的字符串，依次类推……使用<code>.start()</code>和<code>.end()</code>分别返回匹配开始和结束的位置。</p><h3 id="re-search-pattern-string-flags-0"><a href="#re-search-pattern-string-flags-0" class="headerlink" title="re.search(pattern, string, flags=0)"></a>re.search(pattern, string, flags=0)</h3><p>在字符串任意位置进行匹配，查到第一个符合pattern的字符串，返回<strong>“匹配对象”</strong>，如果未匹配到，则返回None。</p><h3 id="re-sub-pattern-repl-string-count-0-flags-0"><a href="#re-sub-pattern-repl-string-count-0-flags-0" class="headerlink" title="re.sub(pattern, repl, string, count=0, flags=0)"></a>re.sub(pattern, repl, string, count=0, flags=0)</h3><p>返回将string中匹配的pattern替换为repl后的字符串，如果未匹配到则返回string。count表示可替换的最大次数，默认为0表示所有的都将被替换。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">https://docs.python.org/3/library/re.html</a><br><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-reg-expressions.html</a></p><hr><p><a id="bib1" href="#bib1ref"><sup>[1]</sup></a> ‘\r’: 换行，光标在上一行；’f’: 换页符；’\v’: 垂直制表符。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>评论系统从Disqus到Valine</title>
      <link href="/2018/09/valine.html"/>
      <url>/2018/09/valine.html</url>
      
        <content type="html"><![CDATA[<p>Yelee主题默认支持三款评论系统：Disqus，多说和友言评论，参见<a href="http://moxfive.coding.me/yelee/2.Basic-Usage/comment.html" target="_blank" rel="noopener">Yelee主题使用说明</a>。而目前多说和友言已经不能用了，Disqus也需要科学上网才可以加载使用，故添加一款新的评论系统势在必行。<br><strong>访客请参考<a href="https://suixinblog.cn/2018/09/valine.html#Valine%E7%9A%84%E4%BD%BF%E7%94%A8">这里</a>进行评论。</strong><br><a id="more"></a></p><h2 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h2><p><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a>是一款优秀的评论系统，漂亮的界面、显示浏览器信息/系统信息、支持匿名评论、支持Markdown、Emoji等都是它的绝对优势，上图</p><p><center><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvoai2bskoj319q0tmtaq.jpg" width="50%" alt="Valine界面" height="50%"></center></p><h2 id="在Yelee中配置"><a href="#在Yelee中配置" class="headerlink" title="在Yelee中配置"></a>在Yelee中配置</h2><p>简单几步，即可完成主题的适配：</p><ol><li>按照<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">官网</a>提示，注册<a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">LeanCloud</a>账号并拿到APP ID和APP Key；</li><li><p>在<code>/yelee/_config.yml</code>中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  on: true</span><br><span class="line">  appid: ***** # App ID</span><br><span class="line">  appkey: ***** # App Key</span><br><span class="line">  verify: true # 验证码</span><br><span class="line">  notify: true # 评论回复邮箱提醒</span><br><span class="line">  avatar: mp # 匿名者头像选项</span><br><span class="line">  placeholder: Just go go!</span><br></pre></td></tr></table></figure><p> <code>CDN:</code>中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valine: //unpkg.com/valine@1.2.0-beta1/dist/Valine.min.js</span><br></pre></td></tr></table></figure></li><li><p>在<code>/yelee/layout/_partial/article.ejs</code>中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% &#125; else if (theme.valine.on)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&apos;comments/valine&apos;, &#123;</span><br><span class="line">        key: post.slug,</span><br><span class="line">        title: post.title,</span><br><span class="line">        url: config.url+url_for(post.path)</span><br><span class="line">      &#125;) %&gt;</span><br></pre></td></tr></table></figure><p> 缩进与其他的评论代码保持一致；</p></li><li><p>创建<code>/yelee/layout/_partial/comments/valine.ejs</code>文件，写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;section id=&quot;comments&quot; style=&quot;margin: 2em; padding: 2em; background: rgba(255, 255, 255, 0.5)&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;&lt;%- theme.CDN.valine %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      new Valine(&#123;</span><br><span class="line">        el: &apos;#vcomment&apos;,</span><br><span class="line">        notify: &apos;&lt;%= theme.valine.notify %&gt;&apos;,</span><br><span class="line">        verify: &apos;&lt;%= theme.valine.verify %&gt;&apos;,</span><br><span class="line">        app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;,</span><br><span class="line">        app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;,</span><br><span class="line">        placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;,</span><br><span class="line">        avatar: &quot;&lt;%= theme.valine.avatar %&gt;&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure></li><li><p>在<code>/yelee/source/css/_partial/mobile.styl</code>最后加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#comments &#123;</span><br><span class="line">    margin: (10/16)rem 10px !important;</span><br><span class="line">    padding: 1rem !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>大功告成，执行<code>hexo g -d</code>即可看到Valine的评论框啦！</p><h2 id="Valine的使用"><a href="#Valine的使用" class="headerlink" title="Valine的使用"></a>Valine的使用</h2><p>评论框支持三个选项：昵称、邮箱、网址。<br><strong>昵称：</strong>展示在评论区的昵称；<br><strong>邮箱：</strong>填写邮箱后若有消息回复即可收到通知（建议填写）；且该邮箱若为在<a href="http://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a>注册的邮箱，填写后可显示自定义的头像；<br><strong>网址：</strong>可填写个人主页，评论后可通过点击昵称跳转到该网址。<br>别忘了，最重要的，Valine支持Markdown语法哦，快在评论区留言吧～</p><h2 id="Valine-Admin"><a href="#Valine-Admin" class="headerlink" title="Valine Admin"></a>Valine Admin</h2><p>一位大神对Valine进行了修改：<a href="https://github.com/panjunwen/Valine-Admin" target="_blank" rel="noopener">Valine Admin</a> 是 Valine 评论系统的扩展和增强，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板，基于Akismet API实现准确的垃圾评论过滤。<br>根据<a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">配置手册</a>进行一番配置，现在本文下方的评论系统已经完美支持邮件提醒了。<br><strong>注</strong>：只有填写了邮箱才可以收到回复的邮件提醒哈～（这不是废话么……）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="https://blog.wangriyu.wang/2018/03-valine.html" target="_blank" rel="noopener">https://blog.wangriyu.wang/2018/03-valine.html</a><br><a href="https://panjunwen.com/valine-admin-document/" target="_blank" rel="noopener">https://panjunwen.com/valine-admin-document/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从Hugo到Hexo</title>
      <link href="/2018/09/hexo.html"/>
      <url>/2018/09/hexo.html</url>
      
        <content type="html"><![CDATA[<p>很多人从Hexo迁移到Hugo，而我却相反，原因是看中了<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">这款主题Yelee</a>。双栏页面、自动更换背景、毛玻璃特效、随机动画、漂亮的代码界面以及非常全的第三方集成，几乎能想到的它都有……一眼看中，不能自拔……<br><a id="more"></a></p><h2 id="使用Hexo搭建博客"><a href="#使用Hexo搭建博客" class="headerlink" title="使用Hexo搭建博客"></a>使用Hexo搭建博客</h2><p><a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a>主页上已经详细说明了搭建的步骤，和Hugo有很多相似之处，但由于Yelee主题的适配，确实为我带来了不少便利之处，很多东西只需修改两个配置文件<code>_config.yml</code>即可。</p><h2 id="Yelee主题的适配"><a href="#Yelee主题的适配" class="headerlink" title="Yelee主题的适配"></a>Yelee主题的适配</h2><p>Yelee作者对于该主题的使用写了详细的说明，很多步骤直接看<a href="http://moxfive.xyz/yelee/" target="_blank" rel="noopener">该文件</a>即可解决。<br>下面列出原文件中比较略/没有解决的几个问题：</p><h3 id="GitHub图标设置后不能显示"><a href="#GitHub图标设置后不能显示" class="headerlink" title="GitHub图标设置后不能显示"></a>GitHub图标设置后不能显示</h3><p>不显示的的原因是原文件中GitHub图标的地址已经失效了，如图<br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fvn0lg3z4oj30ya04qdgr.jpg" alt=""><br><strong>解决方案：</strong>在<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">这里</a>下载一个github图标（推荐# e6e6e6色的纯色图标）放到/yelee/source/img/下并命名为GitHub.png，然后在/yelee/source/css/_partial/customise/social-icon.styl的img-logo中加入<code>GitHub black 75</code>，接着删掉46-50行的即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.GitHub</span><br><span class="line">    background url(//cdn.bootcss.com/logos/0.2.0/github-octocat.svg) no-repeat white</span><br><span class="line">    background-size 90%</span><br><span class="line">    background-position 50% 100%</span><br></pre></td></tr></table></figure></p><h3 id="网站小图标favicon"><a href="#网站小图标favicon" class="headerlink" title="网站小图标favicon"></a>网站小图标favicon</h3><p>将favicon.ico放到<code>/yelee/source/</code>并在配置文件中对应修改后发现不能正常显示。一番探索之后才知道在本地部署草稿的时候是不能正常显示的，但只要执行<code>hexo d</code>正式发布之后即可正常显示。</p><h3 id="搜索引擎优化SEO"><a href="#搜索引擎优化SEO" class="headerlink" title="搜索引擎优化SEO"></a>搜索引擎优化SEO</h3><h4 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h4><p>通过这位同仁给出的优化方案<a href="https://wushao.xyz/posts/687b3092.html" target="_blank" rel="noopener">https://wushao.xyz/posts/687b3092.html</a> 做完之后发现百度不能抓取到sitemap<br>    <img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvn0sanphdj31ia0bitan.jpg" alt=""><br>查了很多才知道是因为GitHub封了百度的蜘蛛……所以目前百度还是没有收录我的网址，哪位大神解决了麻烦在下面留言告诉我哦～</p><h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><p>直接在Google Search Console提交sitemap地址即可，过了一个小时就可以搜到了！</p><p><center><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fvn0xs0y16j317s17g4bv.jpg" width="80%"></center><br>当然是限制了时间才搜索的到……不免感觉有点小悲伤……<br><strong>Tips</strong>：<br>使用文件验证站长的时候，需要在下载的html文件前加入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>否则Hexo会自动将该文件给生成页面，也就不能正常验证了。</p><h3 id="自动部署到GitHub-Pages"><a href="#自动部署到GitHub-Pages" class="headerlink" title="自动部署到GitHub Pages"></a>自动部署到GitHub Pages</h3><p>修改根目录下的_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo: https://github.com/ShaneTian/ShaneTian.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>其中<code>repo</code>为自己的GitHub Pages地址。以后使用代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p><p>即可一键部署网站，前提是在配置文件中填写了自己的域名哦。</p><h2 id="对应的Hugo主题"><a href="#对应的Hugo主题" class="headerlink" title="对应的Hugo主题"></a>对应的Hugo主题</h2><p>一位大神已经将该主题迁移到了Hugo，详见<a href="https://github.com/NightFarmer/hugo-theme-yelee" target="_blank" rel="noopener">https://github.com/NightFarmer/hugo-theme-yelee</a> ，不过没有了首页动画等，但Hugo确实快啊。</p><h2 id="Hexo缺点"><a href="#Hexo缺点" class="headerlink" title="Hexo缺点"></a>Hexo缺点</h2><p>用过Hugo之后再来用Hexo，可以感觉到Hexo的生成速度明显比Hugo慢了一个等级，不过有这么好看的主题也就忍忍了。<br><strong>Tips</strong>：<br>另一款好看的Hexo主题：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>，示例网站见<a href="https://notes.doublemine.me/" target="_blank" rel="noopener">Doublemine</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Hugo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小米笔试题「小米大礼包」Python代码</title>
      <link href="/2018/09/mihomegiftbag.html"/>
      <url>/2018/09/mihomegiftbag.html</url>
      
        <content type="html"><![CDATA[<p>前几天一位朋友问我一道小米的笔试编程题，一看题目，这么简单？直接遍历list再用if判断不就行了。事实证明我还是too naive，写了几句便写不下去了……WTF……<br><a id="more"></a><br>话不多说，上题。</p><p><center> ![](https://ws3.sinaimg.cn/large/006tNbRwly1fvkjhd8b2aj30je0ebt9v.jpg)![](https://ws2.sinaimg.cn/large/006tNbRwly1fvkjj1nhnvj30jh06iaa5.jpg) </center><br>事实上，题目的本质为判断一个集合是否有子集之和等于一个固定的数字。可将问题分为两个子问题：</p><ol><li>包含最后一个数字，循环其余N-1个数字判断是否等于M-set[n-1]；</li><li>去掉最后一个数字，循环其余N-1个数字判断是否等于M</li></ol><p>GeeksforGeeks上一位大牛利用<strong>递归</strong>的思想给出了解题思路，我将部分代码修改如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">miHomeGiftBag</span><span class="params">(n, set, sum)</span>:</span></span><br><span class="line">    <span class="comment"># Base Cases</span></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> <span class="keyword">and</span> sum != <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If last element is greater than sum, then ignore it</span></span><br><span class="line">    <span class="keyword">if</span> (set[n - <span class="number">1</span>] &gt; sum):</span><br><span class="line">        <span class="keyword">return</span> miHomeGiftBag(set, n - <span class="number">1</span>, sum)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    else, check if sum can be obtained by any of the following:</span></span><br><span class="line"><span class="string">    (a) including the last element</span></span><br><span class="line"><span class="string">    (b) excluding the last element</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> miHomeGiftBag(set, n - <span class="number">1</span>, sum) <span class="keyword">or</span> miHomeGiftBag(set, n - <span class="number">1</span>, sum - set[n - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get parameters from terminal</span></span><br><span class="line">N = int(input())</span><br><span class="line">gift_money = list(map(int, input(<span class="string">""</span>).split()))</span><br><span class="line"><span class="comment"># print(gift_money)</span></span><br><span class="line">M = int(input())</span><br><span class="line"></span><br><span class="line">res = miHomeGiftBag(gift_money, N, M)</span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p><strong>测试：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> python3 mi.py</span></span><br><span class="line">2</span><br><span class="line">1 4</span><br><span class="line">6</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 0</span></span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> python3 mi.py</span></span><br><span class="line">4</span><br><span class="line">2 3 8 1</span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.geeksforgeeks.org/subset-sum-problem-dp-25/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/subset-sum-problem-dp-25/</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔试面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用HUGO搭建个人博客</title>
      <link href="/2018/09/hugo.html"/>
      <url>/2018/09/hugo.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a>是一个用Go编写的静态站点生成器，由于具有丰富的主题资源和惊人的生成速度而备受青睐。本博客即是基于Hugo搭建，下面讲述一下我的建站历程以及踩的几个大坑（此处手动Doge…）。<br><a id="more"></a></p><h2 id="安装Hugo以及生成第一篇文章"><a href="#安装Hugo以及生成第一篇文章" class="headerlink" title="安装Hugo以及生成第一篇文章"></a>安装Hugo以及生成第一篇文章</h2><h3 id="安装Hugo"><a href="#安装Hugo" class="headerlink" title="安装Hugo"></a>安装Hugo</h3><p>如果你是<code>macOS</code>用户，请使用<code>Homebrew</code>快速安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install hugo</span><br></pre></td></tr></table></figure></p><p>如果你是<code>Windows</code>用户，请使用<code>Chocolatey</code>或者<code>Scoop</code>快速安装，取决于你使用什么包管理<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install hugo -confirm</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install hugo</span><br></pre></td></tr></table></figure><p>如果你是<code>Debian</code>或<code>Ubuntu</code>用户，请使用<code>apt</code>快速安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install hugo</span><br></pre></td></tr></table></figure></p><p>基本上使用单行命令都可以成功安装Hugo，具体请移步<a href="https://gohugo.io/getting-started/installing" target="_blank" rel="noopener">这里</a>。</p><h3 id="生成文章"><a href="#生成文章" class="headerlink" title="生成文章"></a>生成文章</h3><p>使用如下命令新建一个名为“mysite”的网站：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new site mysite</span><br></pre></td></tr></table></figure></p><p>接下来，在<a href="https://themes.gohugo.io/" target="_blank" rel="noopener">这里</a>找到一个漂亮的网站主题。相信我，Hugo的主题海洋会让你纠结到死……经过一番激烈的挣扎，我最终还是投靠给了<a href="https://themes.gohugo.io/casper/" target="_blank" rel="noopener">Casper</a>，没有什么能比一张大图占据整个屏幕带来的冲击感更强了……（说不定过段时间我又折腾着换别的主题了……）。言归正传，以Casper为例，将主题<code>clone</code>到本地的<code>themes</code>文件夹内，执行以下两句即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes</span><br><span class="line">git clone https://github.com/vjeantet/hugo-theme-casper.git casper</span><br></pre></td></tr></table></figure></p><p><code>mysite/content</code>是用来存放文档的地方，我们在其下建立一个新的<code>Markdown</code>文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new post/first.md</span><br></pre></td></tr></table></figure></p><p>在<code>first.md</code>中写入一些内容，使用如下命令进行本地预览：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo server -t casper -D</span><br></pre></td></tr></table></figure></p><p>几乎瞬间编译成功，打开网址 <a href="http://localhost:1313/" target="_blank" rel="noopener">http://localhost:1313/</a> 即可查看本地生成的静态网站。</p><h2 id="适配主题"><a href="#适配主题" class="headerlink" title="适配主题"></a>适配主题</h2><p>Hugo的每个主题都会有不同的参数配置，而这些配置被存放在根目录下的<code>config.toml</code>文件中，对于<code>Casper</code>主题，<a href="https://github.com/vjeantet/hugo-theme-casper" target="_blank" rel="noopener">官方的GitHub</a>中已经对此作了说明，以下是我的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">BaseUrl= &quot;https://shanetian.github.io/&quot;</span><br><span class="line">LanguageCode= &quot;zh-cn&quot;</span><br><span class="line">Title= &quot;I am thinking ...&quot;</span><br><span class="line">theme = &quot;casper&quot;</span><br><span class="line">paginate = 5</span><br><span class="line">DisqusShortname = &quot;suixin-1&quot;  # name in comments</span><br><span class="line">Copyright = &quot;All rights reserved - 2018&quot;</span><br><span class="line">canonifyurls = true</span><br><span class="line"></span><br><span class="line">[params]</span><br><span class="line">  description = &quot;路在脚下，心向远方&quot;</span><br><span class="line">  metadescription = &quot;Used as &apos;description&apos; meta tag for both home and index pages. If not set, &apos;description&apos; will be used instead&quot;</span><br><span class="line">  cover = &quot;images/boy_bicycle.jpg&quot;</span><br><span class="line">  author = &quot;SuiXin&quot;</span><br><span class="line">  authorlocation = &quot;Chengdu, China&quot;</span><br><span class="line">  authorwebsite = &quot;suixinblog.cn&quot;</span><br><span class="line">  authorbio= &quot;Every man dies, not every man really lives.&quot;</span><br><span class="line">  logo = &quot;images/bird.png&quot;</span><br><span class="line">  # googleAnalyticsUserID = &quot;UA-79101-12&quot;</span><br><span class="line">  # Optional RSS-Link, if not provided it defaults to the standard index.xml</span><br><span class="line">  # RSSLink = &quot;http://feeds.feedburner.com/...&quot;</span><br><span class="line">  githubName = &quot;ShaneTian&quot;</span><br><span class="line">  email = &quot;tianxinyqq@163.com&quot;</span><br><span class="line">  twitterName = &quot;ShaneTian6&quot;</span><br><span class="line">  # facebookName = &quot;&quot;</span><br><span class="line">  # codepenName = &quot;&quot;</span><br><span class="line">  # linkedinName = &quot;&quot;</span><br><span class="line">  # stackoverflowId = &quot;&quot;</span><br><span class="line">  # keybaseName = &quot;&quot;</span><br><span class="line">  # flickrName = &quot;&quot;</span><br><span class="line">  # instagramName = &quot;&quot;</span><br><span class="line">  # pinterestName = &quot;&quot;</span><br><span class="line">  # googlePlusName = &quot;&quot;</span><br><span class="line">  # set true if you are not proud of using Hugo (true will hide the footer note &quot;Proudly published with HUGO.....&quot;)</span><br><span class="line">  hideHUGOSupport = false</span><br><span class="line"></span><br><span class="line">  # Setting a value will load highlight.js and enable syntax highlighting using the style selected.</span><br><span class="line">  # See https://github.com/isagalaev/highlight.js/tree/master/src/styles for available styles</span><br><span class="line">  # A preview of above styles can be viewed at https://highlightjs.org/static/demo/</span><br><span class="line">  hjsStyle = &quot;atom-one-light&quot;</span><br><span class="line"></span><br><span class="line">  [params.social]</span><br><span class="line">    twitter = &quot;ShaneTian6&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">  name = &quot;Home&quot;</span><br><span class="line">  weight = -1</span><br><span class="line">  identifier = &quot;blog&quot;</span><br><span class="line">  url = &quot;/&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">  name = &quot;Machine Learning&quot;</span><br><span class="line">  weight = -2</span><br><span class="line">  identifier = &quot;ml&quot;</span><br><span class="line">  url = &quot;/tags/machine-learning&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">  name = &quot;Others&quot;</span><br><span class="line">  weight = -3</span><br><span class="line">  identifier = &quot;other&quot;</span><br><span class="line">  url = &quot;/tags/others&quot;</span><br><span class="line"></span><br><span class="line">[[menu.main]]</span><br><span class="line">  name = &quot;About&quot;</span><br><span class="line">  weight = -4</span><br><span class="line">  identifier = &quot;about&quot;</span><br><span class="line">  url = &quot;/about&quot;</span><br><span class="line"></span><br><span class="line">  [permalinks]</span><br><span class="line">  post = &quot;/:year/:month/:day/:title/&quot;</span><br></pre></td></tr></table></figure></p><h2 id="文章内的配置"><a href="#文章内的配置" class="headerlink" title="文章内的配置"></a>文章内的配置</h2><p>使用命令<code>hugo new post/***.md</code>新建<code>Markdown</code>文件之后，文章开头会有默认的被<code>+++</code>包住的内容，这些内容即是该文章的配置。在<code>/mysite/archetypes/default.md</code>中可修改默认的配置。以下为我的默认配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+++</span><br><span class="line">title = &quot;&#123;&#123; replace .Name &quot;-&quot; &quot; &quot; | title &#125;&#125;&quot;  # 文章标题</span><br><span class="line">date = &#123;&#123; .Date &#125;&#125;  # 自动添加日期信息</span><br><span class="line">draft = true  # 设为false可被编译为HTML，true供本地修改</span><br><span class="line">tags = [&quot;&quot;]  # 文章标签，可设置多个，用逗号隔开。Hugo会自动生成标签的子URL</span><br><span class="line">comments = true  # 是否开启Disqus评论功能</span><br><span class="line">share = true  # 是否开启分享</span><br><span class="line">+++</span><br></pre></td></tr></table></figure></p><h2 id="代码着色"><a href="#代码着色" class="headerlink" title="代码着色"></a>代码着色</h2><p><code>Casper</code>主题在<code>config.toml</code>文件中的<code>hjsStyle</code>选项提供了<code>highlight.js</code>的代码着色。所有的代码主题和支持的语言可在<a href="https://highlightjs.org/static/demo/" target="_blank" rel="noopener">这里</a>看到。<br>但在实际的配置中更改配置选项发现并没有更改代码的颜色……我……<br>经历了一番数不清的Google之后发现，<code>Casper</code>主题的内置<code>HTML</code>文件设置的<code>highlight.js</code>版本为9.8.0，而现在的<code>highlight.js</code>已经更新到9.12.0，故只需修改<code>/mysite/themes/casper/layouts/partials/header.html</code>中几行代码为9.12.0即可：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; if .Site.Params.hjsStyle &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/&#123;&#123; .Site.Params.hjsStyle &#125;&#125;.min.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    &#123;&#123; if or .Site.Params.hjsExtraLanguages .Params.hjsExtraLanguages &#125;&#125;</span><br><span class="line">        &#123;&#123; range $index, $language := (union .Site.Params.hjsExtraLanguages .Params.hjsExtraLanguages) &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/&#123;&#123; $language &#125;&#125;.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        &#123;&#123; end &#125;&#125;</span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">hljs.initHighlightingOnLoad();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="关于图片"><a href="#关于图片" class="headerlink" title="关于图片"></a>关于图片</h2><p><code>Casper</code>主题需要设置一个封面图和一个作者头像，选好图片放置在<code>/static/images</code>并在<code>/config.toml</code>设置即可。<br>关于浏览器的小图标<code>favicon</code></p><p><center><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvimvpcx7dj30do02g74a.jpg" width="30%" \=""></center><br>可将喜欢的照片在<a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">该网站</a>生成各种分辨率的<code>.ico</code>文件，将其命名为<code>favicon.ico</code>同样放置在<code>/static/images</code>即可。<code>apple-touch-icon</code>同理。</p><h2 id="发布网站到GitHub-Pages"><a href="#发布网站到GitHub-Pages" class="headerlink" title="发布网站到GitHub Pages"></a>发布网站到GitHub Pages</h2><p>在使用<code>hugo server -D</code>预览网站无误后可正式发布网站到域名供大家浏览。将要发布的文章内<code>draft</code>改为<code>false</code>后执行命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo</span><br></pre></td></tr></table></figure></p><p>可看到根目录下多出<code>/public</code>文件夹出来，该文件夹的内容即Hugo生成的整个静态网站。最终我们需要把这些静态网站的文件部署到一个地方，免费且稳定的GitHub Pages是一个很好的选择。具体操作如下：</p><ol><li>在GitHub新建一个Repository命名为<code>ShaneTian.github.io</code>，其中<code>ShaneTian</code>改成自己的GitHub账户名；</li><li>在<code>/mysite</code>外建立一个平行的文件夹，此处假设也命名为<code>/ShaneTian.github.io</code>；</li><li>进入<code>/public</code>文件夹将内容复制到<code>/ShaneTian.github.io</code>；</li><li>将<code>/ShaneTian.github.io</code>的内容<code>push</code>到远程仓库。</li></ol><p>以上命令可在命令行通过以下语句实现：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir ShaneTian.github.io</span><br><span class="line">cd mysite/public</span><br><span class="line">cp -r . ../../ShaneTian.github.io</span><br><span class="line">cd ../../ShaneTian.github.io</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m "commit message"</span><br><span class="line">git remote add origin https://github.com/ShaneTian/ShaneTian.github.io.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>完成以上命令后，等待一分钟左右即可在 <a href="https://shanetian.github.io/" target="_blank" rel="noopener">https://shanetian.github.io/</a> 访问你的网站。<br>以后每次更新文章后只用将生成的<code>/public</code>文件夹的静态网站内容复制到<code>/ShaneTian.github.io</code>，然后再<code>push</code>到远程仓库即可。也可将步骤写为<code>Shell</code>脚本，此处不再赘述。</p><h2 id="使用自己的域名"><a href="#使用自己的域名" class="headerlink" title="使用自己的域名"></a>使用自己的域名</h2><p>当然，GitHub的域名怎么能满足装*的心理，这时可以将网站设置为自己的域名。购买域名的地方很多，如国外知名网站<a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">GoDaddy</a>，简体中文页面、支持支付宝付款、不用备案等都带来了很多方便。我的域名<a href="https://suixinblog.cn">suixinblog.cn</a>即是在此购买。购买域名后完成下面两步即可访问自己的域名：</p><ol><li>在上面存放静态网站的Repository设置里面Custom domain填上自己的域名点击save；</li><li><p>执行以下语句获得自己的GitHub Pages的IP：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping shanetian.github.io</span><br></pre></td></tr></table></figure><p>即可得到下面的IP地址：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvmz2x6huhj30zq04ytbn.jpg" alt=""></p></li><li>在域名提供商的网站配置DNS即可，以Godaddy为例配置两条记录如下：<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvmz5res74j31ic0nqtbg.jpg" alt=""></li><li>可以在GitHub Pages设置强制https协议，这样你的网站就有安全锁啦～<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fvmzc3x3wtj315m0y2jx9.jpg" alt=""><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvmzdi2rllj309o01wjrf.jpg" alt=""></li></ol><p>大功告成！快去访问你的域名吧！<br><strong>Tips</strong>：<br>另外一款好看的Hugo主题：<a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">hugo-nuo</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术驿站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站建设 </tag>
            
            <tag> Hugo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/index.html"/>
      <url>/2018/09/index.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="string">"My New Post"</span></span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
